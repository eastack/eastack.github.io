<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.17">
<meta name="description" content="Protocol Buffers 语言指南翻译。">
<meta name="keywords" content="Protocol Buffers, guidet, ranslate">
<title>Protocol Buffers 语言指南</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href=".asciidoctor/asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href=".asciidoctor/rouge-github.css">
</head>
<body class="article toc2 toc-right">
<div id="header">
<h1>Protocol Buffers 语言指南</h1>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#_定义一个消息类型">定义一个消息类型</a>
<ul class="sectlevel2">
<li><a href="#_指定字段类型">指定字段类型</a></li>
<li><a href="#_分配字段编号">分配字段编号</a></li>
<li><a href="#_指定字段规则">指定字段规则</a></li>
<li><a href="#_添加更多消息类型">添加更多消息类型</a></li>
<li><a href="#_添加注释">添加注释</a></li>
<li><a href="#_保留字段">保留字段</a></li>
<li><a href="#_你的_proto_文件生成了什么">你的 <code>.proto</code> 文件生成了什么</a></li>
</ul>
</li>
<li><a href="#_标量数据类型">标量数据类型</a></li>
<li><a href="#_默认值">默认值</a></li>
<li><a href="#_枚举">枚举</a>
<ul class="sectlevel2">
<li><a href="#_保留值">保留值</a></li>
</ul>
</li>
<li><a href="#_使用其它消息类型">使用其它消息类型</a>
<ul class="sectlevel2">
<li><a href="#_导入定义">导入定义</a></li>
<li><a href="#_使用_proto2_消息类型">使用 proto2 消息类型</a></li>
</ul>
</li>
<li><a href="#_嵌套类型">嵌套类型</a></li>
<li><a href="#_更新一个消息类型">更新一个消息类型</a></li>
<li><a href="#_未知字段">未知字段</a></li>
<li><a href="#_any">Any</a></li>
<li><a href="#_oneof">Oneof</a>
<ul class="sectlevel2">
<li><a href="#_使用_oneof">使用 Oneof</a></li>
<li><a href="#_oneof_特性">Oneof 特性</a></li>
<li><a href="#_向后兼容性问题">向后兼容性问题</a></li>
</ul>
</li>
<li><a href="#_map">Map</a></li>
<li><a href="#_向后兼容性">向后兼容性</a></li>
<li><a href="#_包">包</a>
<ul class="sectlevel2">
<li><a href="#_包和名称解析">包和名称解析</a></li>
</ul>
</li>
<li><a href="#_定义服务">定义服务</a></li>
<li><a href="#_json_映射">JSON 映射</a>
<ul class="sectlevel2">
<li><a href="#_json_选项">JSON 选项</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="quoteblock">
<blockquote>
Protocol buffers are a language-neutral, platform-neutral extensible mechanism for serializing structured data.
</blockquote>
<div class="attribution">
&#8212; https://developers.google.com/protocol-buffers
</div>
</div>
<div class="paragraph">
<p>本指南讲解了如何使用 Protocol Buffer 语言来构造你的 Protocol Buffer 数据，包含 <code>.proto</code> 文件语法以及如何从你的 <code>.proto</code> 文件生成数据访问类。</p>
</div>
<div class="paragraph">
<p>这是一个参考指南 —— 关于一个使用本文档中介绍的许多特性的引导示例，参见你所选语言的对应 <a href="https://developers.google.com/protocol-buffers/docs/tutorials">教程</a> 。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_定义一个消息类型">定义一个消息类型</h2>
<div class="sectionbody">
<div class="paragraph">
<p>首先我们看一个非常简单的示例。
假如说你想定义一个搜索请求格式，每个搜索请求中包含一个 <em>查询字符串</em> ，搜索结果你感兴趣的 <em>页码</em> ，以及 <em>每页结果数</em> 。
那么你可以使用下面这个 <code>.proto</code> 文件来定义你的消息类型。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="protobuf"><span class="na">syntax</span> <span class="o">=</span> <span class="s">"proto3"</span>

<span class="kd">message</span> <span class="nc">SearchRequest</span> <span class="p">{</span>
	<span class="kt">string</span> <span class="na">query</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int32</span> <span class="na">page_number</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="kt">int32</span> <span class="na">result_per_page</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>文件中的第一行指定了你将使用 <code>proto3</code> 语法：如果你不添加这一行那么 Protocol Buffer 编译器将假设你要使用 <a href="https://developers.google.com/protocol-buffers/docs/proto">proto2</a>。
而且必须是文件中第一个非空行并且非注释的行。</p>
</li>
<li>
<p><code>SearchRequest</code> 消息定义指定了三个字段（名/值对）,每一个字段表示你想要包含在消息中数据的一部分。
每个字段都有名称和类型。</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_指定字段类型">指定字段类型</h3>
<div class="paragraph">
<p>在上面的示例中，每个字段都是 <a href="https://developers.google.com/protocol-buffers/docs/proto3#scalar">标量类型</a>：两个整型（ <code>page_number</code> 和 <code>result_per_page</code> ）和一个字符串（ <code>query</code> ）。
但你也可以为你的字段指定复合类型，包括枚举和其他消息类型。</p>
</div>
</div>
<div class="sect2">
<h3 id="_分配字段编号">分配字段编号</h3>
<div class="paragraph">
<p>正如你所看到的，消息定义中的每个字段都有一个 <strong>唯一编号</strong> 。
这些字段编号用来在 <a href="https://developers.google.com/protocol-buffers/docs/encoding">消息二进制格式</a> 中标识你的字段，并且当你的消息类型使用之后就不应再更改它们了。
需要注意的是在范围 1 到 15 的字段编号编码时消耗 1 字节，其中包括字段编号和字段类型（你可以在 <a href="https://developers.google.com/protocol-buffers/docs/encoding#structure">Protocol Buffer 编码</a> 中得到更多相关信息）
范围 16 到 2047 的字段号占用两个字节。
所以你应该为非常频繁出现的字段保留 1 到 15 的字段编号。
并且还要记得为未来可能频繁出现的元素留出一些空间。</p>
</div>
<div class="paragraph">
<p>可以使用的最小字段编号是 1，最大是 2<sup>29</sup> - 1，或 5,3687,0911。
另外你也不能使用 19000 到 19999 的编号（ <code>FieldDescriptor::kFirstReservedNumber</code> 到 <code>FieldDescriptor::kLastReservedNumber</code> ），因为他们是为 Protocol Buffers 实现保留的 —— 如果你在 <code>.proto</code> 文件中使用了其中任意编号编译器将报错。
同样，你也不能使用之前 <a href="https://developers.google.com/protocol-buffers/docs/proto3#reserved">保留</a> 的字段编号。</p>
</div>
</div>
<div class="sect2">
<h3 id="_指定字段规则">指定字段规则</h3>
<div class="paragraph">
<p>消息字段可以是以下两种之一：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>单一：一个符合语法的消息可以包含零个或一个此类字段（但是不能超过一个）。
并且这是 <code>proto3</code> 默认的语法规则。</p>
</li>
<li>
<p>重复（ <code>repeated</code> ）：这种字段在一个符合语法的消息中可以重复任意次（包括零次）。
重复值的顺序将会被保留。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在 proto3 中，标量数字类型的重复（ <code>repeated</code> ）字段默认使用 <code>packed</code> 编码。
你可以在 <a href="https://developers.google.com/protocol-buffers/docs/encoding#packed">Protocol Buffer Encoding</a> 找到更多 <code>packed</code> 编码的信息。</p>
</div>
</div>
<div class="sect2">
<h3 id="_添加更多消息类型">添加更多消息类型</h3>
<div class="paragraph">
<p>多个消息类型可以定义在单个 <code>.proto</code> 文件中。
如果你定义多个相关消息的话这非常有用 —— 比如，如果你想要定义 <code>SearchResponse</code> 消息类型对应的响应消息格式，你可以将其添加到同一个 <code>.proto</code> 文件中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="protobuf"><span class="kd">message</span> <span class="nc">SearchRequest</span> <span class="p">{</span>
	<span class="kt">string</span> <span class="na">query</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int32</span> <span class="na">page_number</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="kt">int32</span> <span class="na">result_per_page</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">message</span> <span class="nc">SearchResponse</span> <span class="p">{</span>
 <span class="o">...</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_添加注释">添加注释</h3>
<div class="paragraph">
<p>要在你的 <code>.proto</code> 文件中添加注释，可以使用 C/C++ 风格的 <code>//</code> 和 <code>/**/</code> 语法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="protobuf"><span class="cm">/* SearchRequest represents a search query, with pagination optionsto
 * indicate wich results to include in the response. */</span>

 <span class="kd">message</span> <span class="nc">SearchRequest</span> <span class="p">{</span>
   <span class="kt">string</span> <span class="na">query</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
   <span class="kt">int32</span> <span class="na">page_number</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>  <span class="c1">// Which page number do we want?</span>
   <span class="kt">int32</span> <span class="na">result_per_page</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// Number of results to return per page.</span>
 <span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_保留字段">保留字段</h3>
<div class="paragraph">
<p>如果你通过完全删除或注释掉某个字段来更新更新一个消息类型，未来的用户可以在对自己的类型进行更新后重新使用这个字段。
如果他们以后再使用同一 <code>.proto</code> 文件的旧版本，会导致非常严重的问题，包括数据损坏，隐私问题等等。
确保这种情况不会发生的一种方法是将你删掉的字段编号（和/或字段名，这会导致 JSON 序列化出现问题）指定为保留（ <code>reserved</code> ）字段。
如果未来的任何用户尝试使用此字段标识，Protocol Buffer 编译器将会报错。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="protobuf"><span class="kd">message</span> <span class="nc">Foo</span> <span class="p">{</span>
  <span class="n">reserved</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">9</span> <span class="k">to</span> <span class="mi">11</span><span class="p">;</span>
  <span class="n">reserved</span> <span class="s">"foo"</span><span class="p">,</span> <span class="s">"bar"</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>注意你不能在同一个 <code>reserved</code> 语句中混用字段名称和字段编号。</p>
</div>
</div>
<div class="sect2">
<h3 id="_你的_proto_文件生成了什么">你的 <code>.proto</code> 文件生成了什么</h3>
<div class="paragraph">
<p>当你使用 <a href="https://developers.google.com/protocol-buffers/docs/proto3#generating">Protocol Buffer 编译器</a> 编译 <code>.proto</code> 文件时，
编译器将根据你选择的语言生成代码，你要使用文件中描述的消息类型，包括获取和设置字段的值、将消息序列化为输出流，以及从输入流中解析消息。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>对于 <strong>C++</strong> ，编译器从每个 <code>.proto</code> 文件生成 <code>.h</code> 和 <code>.cc</code> 文件，并为文件中定义的每个消息类型提供一个类。</p>
</li>
<li>
<p>对于 <strong>Java</strong> ，编译器生成一个 <code>.java</code> 文件，其中包含每个消息类型的类，以及一个用来创建消息类实例的特殊 <code>Builder</code> 类。</p>
</li>
<li>
<p>对于 <strong>Kotlin</strong> ，除了生成的 Java 代码，编译器为每个消息类型都生成了包含用来简化消息实例创建 DSL 的 <code>.kt</code> 文件。</p>
</li>
<li>
<p>对于 <strong>Python</strong> 略有不同 —— Python 编译器会生成一个模块，其中包含 <code>.proto</code> 文件中每种消息类型的静态描述，这些描述将和元类一起在运行时创建所需的数据访问类。</p>
</li>
<li>
<p>对于 <strong>Go</strong> ，编译器会生成一个 <code>.pb.go</code> 文件，其中包含文件中每种消息的类型。</p>
</li>
<li>
<p>对于 <strong>Ruby</strong> ，编译器会生成一个 <code>.rb</code> 文件，其中包含一个含有你所定义消息类型的模块。</p>
</li>
<li>
<p>对于 <strong>Objective-C</strong> ，编译器为每个 <code>.proto</code> 文件生成一个 <code>pbobjc.h</code> 和 <code>pbobjc.m</code> 文件，并为你文件中描述的每种消息类型提供一个类。</p>
</li>
<li>
<p>对于 <strong>C#</strong> ，编译器为每个 <code>.proto</code> 文件生成一个 <code>.cs</code> 文件，为文件中描述的每种消息类型提供一个类。</p>
</li>
<li>
<p>对于 <strong>Dart</strong> ，编译器会生成一个 <code>.pb.dart</code> 文件，其中包含你所定义的每个消息类型的类。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>你可以按照你所选语言的教程（proto3 版本即将推出）了解有关使用每种语言的API的更多信息。
有关 API 的更多详细信息，请参阅相关 <a href="https://developers.google.com/protocol-buffers/docs/reference/overview">API 参考文献</a> (同样 proto3 版本即将推出)。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_标量数据类型">标量数据类型</h2>
<div class="sectionbody">
<div class="paragraph">
<p>一个标量消息字段可以又有下列类型之一 —— 下表现实了 <code>.proto</code> 文件中指定的类型，以及生成类中对应的类型：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 10%;">
<col style="width: 10%;">
<col style="width: 10%;">
<col style="width: 10%;">
<col style="width: 10%;">
<col style="width: 10%;">
<col style="width: 10%;">
<col style="width: 10%;">
<col style="width: 10%;">
<col style="width: 10%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">.proto Type</th>
<th class="tableblock halign-left valign-top">Notes</th>
<th class="tableblock halign-left valign-top">C++ Type</th>
<th class="tableblock halign-left valign-top">Java/Kotlin Type <a href="#_1"><sup>[1]</sup></a></th>
<th class="tableblock halign-left valign-top">Python Type<a href="#_3"><sup>[3]</sup></a></th>
<th class="tableblock halign-left valign-top">Go Type</th>
<th class="tableblock halign-left valign-top">Ruby Type</th>
<th class="tableblock halign-left valign-top">C# Type</th>
<th class="tableblock halign-left valign-top">PHP Type</th>
<th class="tableblock halign-left valign-top">Dart Type</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">float</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">float64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Float</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">float</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">float</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">float</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">float</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">float</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">float32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Float</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">float</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">float</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">int32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint32 instead.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Fixnum or Bignum (as required)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">integer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">int64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint64 instead.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int/long<a href="#_4"><sup>[4]</sup></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bignum</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">integer/string<a href="#_6"><sup>[6]</sup></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Int64</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">uint32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Uses variable-length encoding.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">uint32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int<a href="#_2"><sup>[2]</sup></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int/long<a href="#_4"><sup>[4]</sup></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">uint32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Fixnum or Bignum (as required)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">uint</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">integer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">uint64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Uses variable-length encoding.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">uint64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">long<a href="#_2"><sup>[2]</sup></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int/long<a href="#_4"><sup>[4]</sup></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">uint64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bignum</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ulong</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">integer/string<a href="#_6"><sup>[6]</sup></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Int64</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">sint32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Fixnum or Bignum (as required)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">integer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">sint64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int/long<a href="#_4"><sup>[4]</sup></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bignum</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">integer/string<a href="#_6"><sup>[6]</sup></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Int64</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">fixed32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Always four bytes. More efficient than uint32 if values are often greater than 228.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">uint32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int<a href="#_2"><sup>[2]</sup></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int/long<a href="#_4"><sup>[4]</sup></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">uint32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Fixnum or Bignum (as required)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">uint</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">integer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">fixed64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Always eight bytes. More efficient than uint64 if values are often greater than 256.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">uint64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">long<a href="#_2"><sup>[2]</sup></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int/long<a href="#_4"><sup>[4]</sup></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">uint64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bignum</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ulong</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">integer/string<a href="#_6"><sup>[6]</sup></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Int64</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">sfixed32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Always four bytes.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Fixnum or Bignum (as required)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">integer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">sfixed64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Always eight bytes.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int/long<a href="#_4"><sup>[4]</sup></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bignum</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">integer/string<a href="#_6"><sup>[6]</sup></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Int64</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">boolean</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TrueClass/FalseClass</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">boolean</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A string must always contain UTF-8 encoded or 7-bit ASCII text, and cannot be longer than 232.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">str/unicode<a href="#_5"><sup>[5]</sup></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String (UTF-8)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">May contain any arbitrary sequence of bytes no longer than 232.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ByteString</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">str (Python 2)bytes (Python 3)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[]byte</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String (ASCII-8BIT)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ByteString</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">List</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>当你使用 <a href="https://developers.google.com/protocol-buffers/docs/encoding">Protocol Buffer Encoding</a> 序列化你的消息时，你可以在这里找到更多有关类型编码的信息。</p>
</div>
<div id="_1" class="paragraph">
<p><sup>[1]</sup> Kotlin 使用对应的 Java 类型，甚至无符号类型也和 Java 保持一致，来确保与 Java 代码混用时的兼容性。</p>
</div>
<div id="_2" class="paragraph">
<p><sup>[2]</sup> 在 Java 中，无符号 32 位和 64 位整数使用对应的有符号表示，最高位简单的存储在最高位中。</p>
</div>
<div id="_3" class="paragraph">
<p><sup>[3]</sup> 在所有情况下，位字段赋值都将会执行类型检查来确保值的有效性。</p>
</div>
<div id="_4" class="paragraph">
<p><sup>[4]</sup> 64 位或无符号 32 位整数在解码时始终表示为长整型，但当位字段赋值时如果需要整型则可以是整型 。
在任何情况下，设置的值应该与表示的类型相匹配。</p>
</div>
<div id="_5" class="paragraph">
<p><sup>[5]</sup> Python 字符串在解码是表示位 unicode 但如果是一个 ASCII 字符串也可以表示位 str</p>
</div>
<div id="_6" class="paragraph">
<p><sup>[6]</sup> 整型使用于 64 位机器上，string 用在 32 位机器上。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_默认值">默认值</h2>
<div class="sectionbody">
<div class="paragraph">
<p>当一个消息被解析后，如果解码后的消息不包含某些单例元素，解析后对象中对应的值将被设置为此字段的默认值。
默认值是特定于类型的：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>对于字符串，默认值是空字符串。</p>
</li>
<li>
<p>对于字节，默认值是空字节。</p>
</li>
<li>
<p>对于布尔值，默认值是 false。</p>
</li>
<li>
<p>对于数值类型，默认值是零。</p>
</li>
<li>
<p>对于 <a href="https://developers.google.com/protocol-buffers/docs/proto3#enum">枚举</a> 类型，默认值是 <strong>定义的首个枚举值</strong> ，其编号必须为 0。</p>
</li>
<li>
<p>对一消息类型，该字段没有设置。确切的值于语言相关。详见 <a href="https://developers.google.com/protocol-buffers/docs/reference/overview">代码生成指南</a>。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>重复字段的默认值为空（通常是对应语言中的空值）</p>
</div>
<div class="paragraph">
<p>对于消息中的标量字段需要注意，消息一经解析就再也无法得知一个字段是显式设置为默认值（例如对于布尔值将设置为 <code>false</code> ）还是直接没有设置：
当你定义消息类型时这一点你应该铭记于心。
所以，当你不希望某些行为默认发生时，不要使用布尔值来切换某些行为。
同时注意如果标量消息字段设置为其默认值时，这个值将不会被序列化到线上<a href="#default_value_1"><sup>[1]</sup></a>。</p>
</div>
<div class="paragraph">
<p>查看你选择语言的 <a href="https://developers.google.com/protocol-buffers/docs/reference/overview">代码生成指南</a> 获得更多关于生成的代码中默认值的工作细节。</p>
</div>
<div id="default_value_1" class="paragraph">
<p><sup>[1]</sup> “线上”格式是指一个可解析消息的物理表示，更多可参考 <a href="https://www.ibm.com/docs/en/developer-for-zos/9.1.1?topic=messages-xml-wire-format">XML wire format</a>。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_枚举">枚举</h2>
<div class="sectionbody">
<div class="paragraph">
<p>当你定义一个消息类型时，你可能希望其中一个字段的值是一个预定义列表中某一个值。
例如，假设你想要为每个 <code>SearchRequest</code> 添加一个 <code>corpus</code> 字段，这里 corpus 可以是 <code>UNIVERSAL</code> ， <code>WEB</code> ， <code>IMAGES</code> ， <code>LOCAL</code> ， <code>NEWS</code> ， <code>PRODUCTS</code> 或 <code>VIDEO</code> 。
这可以通过在你定义的消息中添加一个包含每种可能常量值的 <code>enum</code>  轻松搞定。</p>
</div>
<div class="paragraph">
<p>下面的示例中我们添加了一个名为 <code>Corpus</code> 的 <code>enum</code> 以及一个类型为 <code>Corpus</code> 的字段：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="protobuf"><span class="kd">message</span> <span class="nc">SearchRequest</span> <span class="p">{</span>
  <span class="kt">string</span> <span class="na">query</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">int32</span> <span class="na">page_number</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="kt">int32</span> <span class="na">result_per_page</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
  <span class="kd">enum</span> <span class="n">Corpus</span> <span class="p">{</span>
    <span class="na">UNIVERSAL</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="na">WEB</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="na">IMAGES</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="na">LOCAL</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="na">NEWS</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="na">PRODUCTS</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="na">VIDEO</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">Corpus</span> <span class="na">corpus</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如你所见， <code>Corpus</code> 枚举的第一个常量映射到了编号 0：每个枚举的定义都 <strong>必须</strong> 包含一个映射到编号 0 的常量作为其首个元素。
这是因为：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>必须有一个为零的值，这样我们就能将 0 作为数字默认值。</p>
</li>
<li>
<p>在 <code>proto2</code> 中第一个枚举值总是被作为默认值，为了保持与其语义的兼容，这里零值必须是第一个元素。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>你可以通过定义别名来分配相同的值到不同的枚举常量。
为此，你需要将 <code>allow_alias</code> 选项设置为 <code>true</code> ，否则当 protocol 编译器发现别名时将会抛出错误信息。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="protobuf"><span class="kd">message</span> <span class="nc">MyMessage1</span> <span class="p">{</span>
  <span class="kd">enum</span> <span class="n">EnumAllowingAlias</span> <span class="p">{</span>
    <span class="k">option</span> <span class="na">allow_alias</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
    <span class="na">UNKNOWN</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="na">STARTED</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="na">RUNNING</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">message</span> <span class="nc">MyMessage2</span> <span class="p">{</span>
  <span class="kd">enum</span> <span class="n">EnumNotAllowingAlias</span> <span class="p">{</span>
    <span class="na">UNKNOWN</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="na">STARTED</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="c1">// RUNNING = 1;  // Uncommenting this line will cause a compile error inside Google and a warning message outside.</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>枚举常量必须在 32 位整型的范围内。
因为 <code>enum</code> 值处理时使用 <a href="https://developers.google.com/protocol-buffers/docs/encoding">Varint 编码</a>，因为对负数进行编码效率低下因此不推荐使用。
你可以将 <code>enum</code> 定义在消息定义内部（就像上面例子中展示的）或外部 —— 这种 <code>enum</code> 可以在整个 <code>.proto</code> 文件中的所有消息定义中使用。
你也可以使用 <code><em>MessageType</em>.<em>EnumType</em></code> 这种语法来将一个消息中定义的 <code>enum</code> 类型作为其它消息的字段类型。</p>
</div>
<div class="paragraph">
<p>当你使用 Protocol Buffer 编译器编译一个包含 <code>enum</code> 定义的 <code>.proto</code> 文件时，
对于 Java、Kotlin 或 C++ 来说生成的代码中将会包含对应的 <code>enum</code> ，
而对 Python 来说将会生成一个用来在运行时生成的类中创建常量符号与整型值集合 的特殊类 <code>EnumDescriptor</code> 。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<strong>警告</strong> 生成的代码可能会受到特定语言的枚举数限制（low thousands for one language）。
所以请检查你所使用语言的限制。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在反序列化时，无法识别的枚举值将会被保留在消息中，
尽管消息反序列化时如何进行表示是特定于语言的。
在支持值可超出指定符号范围之外的开放枚举类型的语言比如 C++ 和 Go，
未知的枚举值被简单的存储为其底层整数表示。
在封闭枚举类型的语言中例如 Java，枚举中的一个用例被用来存储无法识别的值，并且底层的整数可以通过特殊的访问器进行访问。
在这两种情况下，如果消息被序列化，那么无法识别的值也会和消息一起进行序列化。</p>
</div>
<div class="paragraph">
<p>关于消息中的 <code>enum</code> 在你的应用中是如何工作的可以查看你所使用语言的 <a href="https://developers.google.com/protocol-buffers/docs/reference/overview">代码生成指南</a>。</p>
</div>
<div class="sect2">
<h3 id="_保留值">保留值</h3>
<div class="paragraph">
<p>如果你通过直接删除或注释掉的形式完全移除了一个枚举条目来更新枚举类型，将来的用户可以在进行自己的重新时使用这个数字值。
如果他们之后又使用了同一 <code>.proto</code> 文件的旧版本，这可能会导致严重的问题，包括数据损坏，隐私问题等。
确保这不会发生的一种方式是将你删除的条目的数字值指定为预留（ <code>reserved</code> ）。如果将来有用户尝试使用这些标识符 Protocol Buffer 编译器将会抛出错误。
你可以通过使用 <code>max</code> 关键字指定保留的数字值范围达到最大可能值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="protobuf"><span class="kd">enum</span> <span class="n">Foo</span> <span class="p">{</span>
  <span class="n">reserved</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">9</span> <span class="k">to</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">40</span> <span class="k">to</span> <span class="k">max</span><span class="p">;</span>
  <span class="n">reserved</span> <span class="s">"FOO"</span><span class="p">,</span> <span class="s">"BAR"</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>注意你不能在一个 <code>reserved</code> 语句中混用字段名和数字值。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_使用其它消息类型">使用其它消息类型</h2>
<div class="sectionbody">
<div class="paragraph">
<p>你可以使用其他消息类型作为字段类型。
比如说，你想要将 <code>Results</code> 消息放到每个 <code>SearchResponse</code> 消息中 —— 你可以在同一个 <code>.proto</code> 文件中定义一个 <code>Result</code> 消息类型然后在 <code>SearchResponse</code> 指定一个 <code>Result</code> 类型的字段：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="protobuf"><span class="kd">message</span> <span class="nc">SearchResponse</span> <span class="p">{</span>
  <span class="k">repeated</span> <span class="n">Result</span> <span class="na">results</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">message</span> <span class="nc">Result</span> <span class="p">{</span>
  <span class="kt">string</span> <span class="na">url</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">string</span> <span class="na">title</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">repeated</span> <span class="kt">string</span> <span class="na">snippets</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_导入定义">导入定义</h3>
<div class="paragraph">
<p>在上面的示例中，<code>Result</code> 消息类型和 <code>SearchResponse</code> 定义在同一个文件中 —— 那如果你想用一个定义在另一个 <code>.proto</code> 文件中的消息类型作为字段类型那？</p>
</div>
<div class="paragraph">
<p>你可以通过 <em>导入</em> 他们来使用定义在其他 <code>.proto</code> 文件中的定义。
为了导入其他 <code>.proto</code> 定义，你需要在你的文件头部添加一个导入语句：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="protobuf"><span class="k">import</span> <span class="s">"myproject/other_protos.proto"</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，你只能使用直接导入的 <code>.proto</code> 文件中的定义。
但无论如何，有时你可能需要将 <code>.proto</code> 文件移动到一个新的位置。
相比于直接移动 <code>.proto</code> 文件然后一次性修改所有引用，你可以在旧的位置放一个占位用的 <code>.proto</code> 文件，
使用 <code>import public</code> 标记重定向所有导入到新的位置。</p>
</div>
<div class="paragraph">
<p><strong>注意 <code>public import</code> 功能目前在 Java 中暂时还不支持</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre>`import public` dependencies can be transitively relied upon by any code importing the proto containing the `import public` statement.
// 这里是在不知道该怎么翻译（编）了</pre>
</div>
</div>
<div class="paragraph">
<p><code>import public</code> 的依赖可以通过任何导入包含 <code>import public</code> 语句的 <code>proto</code> 的代码进行传递。
例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="protobuf"><span class="c1">// new.proto</span>
<span class="c1">// All defintions are moved here</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="protobuf"><span class="c1">// old.proto</span>
<span class="c1">// This is the proto that all clients are importing.</span>
<span class="k">import</span> <span class="n">public</span> <span class="s">"new.proto"</span><span class="p">;</span>
<span class="k">import</span> <span class="s">"other.proto"</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="protobuf"><span class="c1">// client.proto</span>
<span class="k">import</span> <span class="s">"old.proto"</span><span class="p">;</span>
<span class="c1">// You use defintions from old.proto and new.proto, but not other.proto</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Protocol 编译器使用在命令行中使用 <code>-I</code> / <code>--proto_path</code> 标志指定的目录集合中搜索导入的文件。
如果没有指定此标志，编译器在被调用的目录下查找。
通常你应该将 <code>--proto_path</code> 标志设置为项目根目录并在所有导入而地方使用全限定名。</p>
</div>
</div>
<div class="sect2">
<h3 id="_使用_proto2_消息类型">使用 proto2 消息类型</h3>
<div class="paragraph">
<p>可以导入 proto2 消息类型并用在 proto3 消息中，反过来也是这样。
无论如何，proto2 枚举无法直接用在 proto3 语法中（如果导入的 proto2 消息使用那没有问题）。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_嵌套类型">嵌套类型</h2>
<div class="sectionbody">
<div class="paragraph">
<p>你可以定义并将消息类型用在其他消息类型中，如下所示 —— 这里 <code>Result</code> 消息定义在 <code>SearchResponse</code> 消息中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="protobuf"><span class="kd">message</span> <span class="nc">SearchResponse</span> <span class="p">{</span>
  <span class="kd">message</span> <span class="nc">Result</span> <span class="p">{</span>
    <span class="kt">string</span> <span class="na">url</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">string</span> <span class="na">title</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">repeated</span> <span class="kt">string</span> <span class="na">snippets</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">repeat</span> <span class="n">Result</span> <span class="na">results</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你想在父消息类型外重用此消息类型，你可以像 <code><em>Parent</em>.<em>Type</em></code> 这样应用它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="protobuf"><span class="kd">message</span> <span class="nc">SomeOtherMessage</span> <span class="p">{</span>
  <span class="n">SearchResponse.Result</span> <span class="na">result</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>你还可以按照你的需求对消息进行嵌套：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="protobuf"><span class="kd">message</span> <span class="nc">Outer</span> <span class="p">{</span>      <span class="c1">// Level 0</span>
  <span class="kd">message</span> <span class="nc">MiddleAA</span> <span class="p">{</span>   <span class="c1">// Level1</span>
    <span class="kd">message</span> <span class="nc">Inner</span> <span class="p">{</span>      <span class="c1">// Level2</span>
      <span class="kt">int64</span> <span class="na">ival</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="kt">bool</span> <span class="na">booly</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">message</span> <span class="nc">MiddleBB</span> <span class="p">{</span>   <span class="c1">// Level1</span>
    <span class="kd">message</span> <span class="nc">Inner</span> <span class="p">{</span>      <span class="c1">// Level2</span>
      <span class="kt">int32</span> <span class="na">ival</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="kt">bool</span> <span class="na">booly</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_更新一个消息类型">更新一个消息类型</h2>
<div class="sectionbody">
<div class="paragraph">
<p>如果现有而消息类型无法满足你所有的需求 —— 比如，
你希望为消息格式添加一个附加字段 —— 但你还想使用旧格式创建的代码，别慌！
要做到更新消息类型而不损坏任何之前已经存在的代码真的非常简单。
只要记住下面这几个规则就可以：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>不要修改任何已有字段的字段编号</p>
</li>
<li>
<p>如果你添加了一个新的字段，任何使用你的“旧”消息格式序列化的消息仍然可以被新生成的代码解析。
你应该将这些元素的默认值铭记于心，从而保证新代码可以与旧代码生成的消息正确交互。
同样，新代码创建的消息也可以被旧代码解析：旧的二进制文件只是在解析时简单的将新字段忽略掉。
详情查看 <a href="https://developers.google.com/protocol-buffers/docs/proto3#unknowns">未知字段</a> 这一章。</p>
</li>
<li>
<p>只要更新的消息类型中不再使用这个字段号，就可以删除这个字段。
你可能想要重命名这个字段，也许是添加前缀 “OBSOLETE_” 或者让字段编号成为被 <a href="https://developers.google.com/protocol-buffers/docs/proto3#reserved">预留</a> 的，这样将来的用户在你的 <code>.proto</code> 文件中就不会意外重用这些编号了。</p>
</li>
<li>
<p><code>int32</code> ， <code>uint32</code> , <code>int64</code> , <code>uint64</code> 以及 <code>bool</code> 都是兼容的 ——
这意味着你可以修改一个字段从这些类型中的一个类型到另一个，
而不破坏向后或向前的兼容性。
如果从线上解析出一个数字但其并不与对应的类型匹配，你将得到与你在 C++ 中手动强转为该类型相同的效果
（比如，一个 64 位的数字被读取为 32 位，其将被截断为 32 位）。</p>
</li>
<li>
<p><code>sint32</code> 和 <code>sint64</code> 之间是相互兼容的，但与其他整数类型不兼通。</p>
</li>
<li>
<p>对于 <code>string</code> 和 <code>bytes</code> 来说，只要自己诶是有效的 UTF-8 彼此之间就是兼容的。</p>
</li>
<li>
<p>如果字节包含消息的编码版本，那么潜入消息和字节兼容。</p>
</li>
<li>
<p><code>fixed32</code> 与 <code>sfixed32</code> 兼容，<code>fixed64</code> 与 <code>sfixed64</code> 兼容。</p>
</li>
<li>
<p>对于 <code>string</code> ， <code>bytes</code> 及消息字段， <code>optional</code> 与 <code>repeated</code> 是兼容的。
给出一个重复字段的序列化数据作为输入，如果对应字段是原始类型的，那么希望获取一个可选字段的客户端将会使用最后一个输入值，
或者对应字段是一个消息类型字段，那么将会合并所有的输入。
需要注意的是，这对于数字类型（包括布尔值和枚举）通常是 <strong>不</strong> 安全的。
数字类型的重复字段将以 [packed] 格式进行打包，当期待获得一个 <code>optional</code> 字段时将会无法正确解析。</p>
</li>
<li>
<p><code>enum</code> 与 <code>int32</code> ， <code>uint32</code> ， <code>int64</code> 及 <code>uint64</code> 在物理表示上是兼容的（切记， 如果类型不匹配，值将会被截断），
但还是要注意，消息反序列化时客户端可能以不同的方式处理他们：
例如，无法识别的枚举类型将被暴露在消息中，但是当消息被反序列化时如何表示则是特定于语言的。
整型字段总是只保留他们的值。</p>
</li>
<li>
<p>TODO: 将单个值改为新 <code>oneof</code> 的成员是安全且二进制兼容的。Changing a single value into a member of a new oneof is safe and binary compatible. Moving multiple fields into a new oneof may be safe if you are sure that no code sets more than one at a time. Moving any fields into an existing oneof is not safe.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_未知字段">未知字段</h2>
<div class="sectionbody">
<div class="paragraph">
<p>未知字段是协议良好（well-formed）的 Protocol Buffer 序列化数据，表示解析器无法识别的字段。
例如：当旧的二进制解析一个带有新字段的新二进制数据时，这些新的字段在就的二进制中就是未知字段。</p>
</div>
<div class="paragraph">
<p>最初，proto3 消息在解析时总是丢弃未知字段，但在版本 3.5 中我们又重新引入了对未知字段的保留一次来匹配 proto2 的行为。
在版本 3.5 及更高的版本中，未知字段在解析时保留并包含在序列化输出中。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_any">Any</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>Any</code> 消息类型可以让你将消息作为嵌入类型而无需定义他们的 <code>.proto</code> 。
<code>Any</code> 可以包含任意序列化为 <code>bytes</code> 的消息，并附加一个作为全局唯一标识符用来解析消息类型的 URL。
要使用 <code>Any</code> 类型，你需要 <a href="https://developers.google.com/protocol-buffers/docs/proto3#other">导入</a> <code>google/protobuf/any.proto</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="protobuf"><span class="k">import</span> <span class="s">"google/protobuf/any.proto"</span><span class="p">;</span>

<span class="kd">message</span> <span class="nc">ErrorStatus</span> <span class="p">{</span>
  <span class="kt">string</span> <span class="kd">message</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">repeated</span> <span class="n">google.protobuf.Any</span> <span class="na">details</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>给定消息类型的默认 URL 是 <code>type.googleapis.com/<em>packagename</em>.<em>messagename</em></code> 。</p>
</div>
<div class="paragraph">
<p>不同语言实现支持使用运行时库从而以类型安全的形式来辅助打包或拆包 Any 值 —— 例如：
在 Java 中 Any 类型会有 <code>pack()</code> 和 <code>unpack()</code> 访问器，而在 C++ 中则有 <code>PackFrom()</code> 和 <code>UnpackTo()</code> 方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="c1">// Storing an arbitrary message type in Any.</span>
<span class="n">NetworkErrorDetails</span> <span class="n">details</span> <span class="o">=</span> <span class="p">...;</span>
<span class="n">ErrorStatus</span> <span class="n">status</span><span class="p">;</span>
<span class="n">status</span><span class="p">.</span><span class="n">add_details</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">PackFrom</span><span class="p">(</span><span class="n">details</span><span class="p">);</span>

<span class="c1">// Reading an arbitrary message from Any.</span>
<span class="n">ErrorStatus</span> <span class="n">status</span> <span class="o">=</span> <span class="p">...;</span>
<span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">Any</span><span class="o">&amp;</span> <span class="n">detail</span> <span class="o">:</span> <span class="n">status</span><span class="p">.</span><span class="n">details</span><span class="p">())</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">detail</span><span class="p">.</span><span class="n">Is</span><span class="o">&lt;</span><span class="n">NetworkErrorDetails</span><span class="o">&gt;</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">NetworkErrorDetails</span> <span class="n">network_error</span><span class="p">;</span>
    <span class="n">detail</span><span class="p">.</span><span class="n">UnpackTo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">network_error</span><span class="p">);</span>
    <span class="p">...</span> <span class="n">processing</span> <span class="n">network_error</span> <span class="p">...</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>现在与 Any 类型配合使用的运行时库仍在开发中。</strong></p>
</div>
<div class="paragraph">
<p>如果你已经熟悉 <a href="https://developers.google.com/protocol-buffers/docs/proto">proto2 语法</a>，
<code>Any</code> 可以保存任何 proto3 消息，这和 可以允许扩展的 proto2 消息类似。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_oneof">Oneof</h2>
<div class="sectionbody">
<div class="paragraph">
<p>如果你的消息有许多字段但同时只会设置一个字段，你可以使用 oneof 特性强制保证此行为来节省内存。</p>
</div>
<div class="paragraph">
<p>除了在 oneof 中所有字段共享内存并且同时只能设置一个值之外，其他方面 oneof 字段与普通字段没有什么不同。
设置任何 oneof 的成员都将会晴空其他成员的值。
取决于你所选择的语言你可以使用 <code>case()</code> 或 <code>WhichOneof()</code> 等特殊方法来检查 oneof 中设置了那个值。</p>
</div>
<div class="sect2">
<h3 id="_使用_oneof">使用 Oneof</h3>
<div class="paragraph">
<p>要在你的 <code>.proto</code> 文件中定义一个 oneof 你可以像下列示例中 <code>test_oneof</code> 那样使用 <code>oneof</code> 关键字后跟 oneof 的名称：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="protobuf"><span class="kd">message</span> <span class="nc">SampleMessage</span> <span class="p">{</span>
  <span class="k">oneof</span> <span class="n">test_oneof</span> <span class="p">{</span>
    <span class="kt">string</span> <span class="na">name</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="n">SubMessage</span> <span class="na">sub_message</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>之后将你的 oneof 字段添加到定义中就可以了。
你可以添加除 <code>map</code> 和 <code>repeated</code> 字段外的任何字段。</p>
</div>
<div class="paragraph">
<p>在你生成的代码中，oneof 字段拥有和普通字段一样的 getters 和 setters。
你也会获得一个用来检查那个值（if any）在 oneof 中被设置的特殊方法。
你可以在你所选语言的相关 <a href="https://developers.google.com/protocol-buffers/docs/reference/overview">API 参考文献</a> 中获得更多 oneof API 相关信息。</p>
</div>
</div>
<div class="sect2">
<h3 id="_oneof_特性">Oneof 特性</h3>
<div class="ulist">
<ul>
<li>
<p>在 oneof 中设置一个 oneof 字段将会自动清除其他成员的值。
所以如果你设置了一些 oneof 字段，则只有 <em>最后</em> 一个字段会有值。</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">SampleMessage</span> <span class="n">message</span><span class="p">;</span>
<span class="n">message</span><span class="p">.</span><span class="n">set_name</span><span class="p">(</span><span class="s">"name"</span><span class="p">);</span>
<span class="n">CHECK</span><span class="p">(</span><span class="n">message</span><span class="p">.</span><span class="n">has_name</span><span class="p">());</span>
<span class="n">message</span><span class="p">.</span><span class="n">mutable_sub_message</span><span class="p">();</span> <span class="c1">//Will clear name field.</span>
<span class="n">CHECK</span><span class="p">(</span><span class="o">!</span><span class="n">message</span><span class="p">.</span><span class="n">has_name</span><span class="p">());</span></code></pre>
</div>
</div>
</li>
<li>
<p>如果解析器在线上遇到了同一 oneof 的多个成员，仅在最终解析出的消息中使用最后一个成员。</p>
</li>
<li>
<p>oneof 不能是 <code>repeated</code></p>
</li>
<li>
<p>在 oneof 上可以使用反射接口</p>
</li>
<li>
<p>如果你将一个 oneof 字段设置为默认值（比如将 int32 设置为 0），
那么这个 oneof 字段的“case”将被设置，并且值将被序列化到线上。</p>
</li>
<li>
<p>如果你使用 C++，请确保你的代码不会导致内存泄漏/崩溃。
下边这个简单示例将会导致崩溃，因为 <code>sub_message</code> 已经在调用 <code>set_name()</code> 方法时被删除了。</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="protobuf"><span class="n">SampleMessage</span> <span class="n">message</span><span class="p">;</span>
<span class="n">SubMessage</span><span class="err">*</span> <span class="na">sub_message</span> <span class="o">=</span> <span class="n">message.mutable_sub_message</span><span class="p">();</span>
<span class="n">message.set_name</span><span class="p">(</span><span class="s">"name"</span><span class="p">);</span>  <span class="c1">// Will delete sub_message</span>
<span class="n">sub_message</span><span class="o">-</span><span class="err">&gt;</span><span class="n">set...</span>        <span class="c1">// Crashes here</span></code></pre>
</div>
</div>
</li>
<li>
<p>还是在 C++ 中，如果你使用 oneof 的 <code>Swap()</code> 方法交换两个消息，那么两个消息最终会变为另一个 oneof 用例：在下面的示例中， 最终 <code>msg1</code> 将会拥有 <code>sub_message</code> 而 <code>msg2</code> 会拥有 <code>name</code> 。</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="protobuf"><span class="n">SampleMessage</span> <span class="n">msg1</span><span class="p">;</span>
<span class="n">msg1.set_name</span><span class="p">(</span><span class="s">"name"</span><span class="p">);</span>
<span class="n">SampleMessage</span> <span class="n">msg2</span><span class="p">;</span>
<span class="n">msg2.mutable_sub_message</span><span class="p">();</span>
<span class="n">msg1.swap</span><span class="p">(</span><span class="err">&amp;</span><span class="n">msg2</span><span class="p">);</span>
<span class="n">CHECK</span><span class="p">(</span><span class="n">msg1.has_sub_message</span><span class="p">());</span>
<span class="n">CHECK</span><span class="p">(</span><span class="n">msg2.has_name</span><span class="p">());</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_向后兼容性问题">向后兼容性问题</h3>
<div class="paragraph">
<p>在移除 oneof 字段时一定要小心。
如果检查一个 oneof 的值返回了 <code>None</code> / <code>NOT_SET</code> ，
这可能意味着 oneof 没有被设置或者其已经被设置到不同本版中的 oneof 字段上了。
因为这里没有办法知道线上的未知字段是不是 oneof 的成员，所以也就没法区分这两种情况。</p>
</div>
<div class="sect3">
<h4 id="_标签重用问题">标签重用问题</h4>
<div class="ulist">
<ul>
<li>
<p><strong>将字段移入或移出 oneof</strong>：你可能会在消息序列化和解析时丢失掉某些信息（某些字段将会被清空）。
However, you can safely move a single field into a new oneof and may be able to move multiple fields if it is known that only one is ever set.</p>
</li>
<li>
<p><strong>删除一个 oneof 字段然后再添加回来</strong>：这可能会在消息被序列化和解析后清除你当前设置的 oneof 字段。</p>
</li>
<li>
<p><strong>拆分或合并 oneof</strong>：这和移动普通字段有类似的问题。</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_map">Map</h2>
<div class="sectionbody">
<div class="paragraph">
<p>如果你想创建一个关联映射作为你数据定义的一部分，Protocol Buffers 提供了方便快捷的语法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="protobuf"><span class="n">map</span><span class="o">&lt;</span><span class="n">key_type</span><span class="p">,</span> <span class="n">value_type</span><span class="err">&gt;</span> <span class="na">map_field</span> <span class="o">=</span> <span class="n">N</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这里 <code>key_type</code> 可以是任何整数或字符串类型（也就是说，可以是除了浮点类型和字节类型之外的任何类型）。
要注意的是枚举并不是有效的 <code>key_value</code> 。
而 <code>value_type</code> 可以是除了另一个映射之外的任何类型。</p>
</div>
<div class="paragraph">
<p>所以，比如，当你想要创建一个项目映射其中每个 <code>Project</code> 消息都和一个字符串键相关联，那么你可以像下面这样进行定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="protobuf"><span class="n">map</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="n">Project</span><span class="err">&gt;</span> <span class="na">projects</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>映射字段不以是可重复的（ <code>repeated</code> ）。</p>
</li>
<li>
<p>线上格式的顺序和映射的遍历顺序对于映射值来说都是不明确的，因此你不能依赖你的映射条目是有特定顺序的。</p>
</li>
<li>
<p>当为 <code>.proto</code> 生成文本格式时，映射按键排序，数据键按数字排序。</p>
</li>
<li>
<p>当从线上解析或合并时，如果有重复的映射键，那么使用最后的键。
当从文本格式解析映射时，如果有重复的键解析可能会失败。</p>
</li>
<li>
<p>如果你为一个映射提供了键但没有值，字段的序列化行为是特定于语言的。
在 C++，Java，Kotlin 和 Python 中对应类型的默认值被序列化，而在其他语言中没有任何东西被序列化。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当前生成的映射 API 已在所有支持 proto3 的语言中可用。
你可以查看你所选语言的 <a href="https://developers.google.com/protocol-buffers/docs/reference/overview">API 参考文档</a> 查看更映射 API 的信息。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_向后兼容性">向后兼容性</h2>
<div class="sectionbody">
<div class="paragraph">
<p>映射的语法在线上等同于下列定义，所以不支持映射的 Protocl Buffer 实现仍然可以处理你的数据：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="protobuf"><span class="kd">message</span> <span class="nc">MapFieldEntry</span> <span class="p">{</span>
  <span class="n">key_type</span> <span class="na">key</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">value_type</span> <span class="na">value</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">repeated</span> <span class="n">MapFieldEntry</span> <span class="na">map_field</span> <span class="o">=</span> <span class="n">N</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>任何支持映射的 Protocol Buffer 实现都必须可以生成和接受上述定义可接受的数据。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_包">包</h2>
<div class="sectionbody">
<div class="paragraph">
<p>你可以在 <code>.proto</code> 文件中添加一个可选的 <code>package</code> 说明符来避免 Protocol 消息类型的命名冲突。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>package foo.bar;
message Open { ... }</pre>
</div>
</div>
<div class="paragraph">
<p>同样你也可以在定义你的消息类型时使用包说明符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="protobuf"><span class="kd">message</span> <span class="nc">Foo</span> <span class="p">{</span>
  <span class="o">...</span>
  <span class="n">foo.bar.Open</span> <span class="na">open</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="o">...</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>包说明符对生成代码的影响方式是特定于语言的：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在 *C* 中生成的类被包装在一个 C 明明空间中。
例如， <code>Open</code> 将会在 <code>foo::bar</code> 命名空间下。</p>
</li>
<li>
<p>在 <strong>Java</strong> 和 <strong>Kotlin</strong> 中，包说明符被用作 Java 的包，除非你在你的 <code>.proto</code> 文件中明确提供了 <code>option java_package</code> 选项。</p>
</li>
<li>
<p>在 <strong>Python</strong> 中，包指令是被忽略的，因为 Python 是根据他们在文件系统中的位置组织的。</p>
</li>
<li>
<p>在 <strong>Go</strong> 中，包被用于 Go 的包名，除非你在你的 <code>.proto</code> 文件中明确提供了 <code>option go_package</code> 选项。</p>
</li>
<li>
<p>在 <strong>Ruby</strong> 中，生成的类包裹在嵌套的 Ruby 命名空间中，被转换为 Ruby 要求的大写风格（首字母大写；如果第一个字符不是字母， 将会使用 <code>PB_</code> 前缀修饰）。
例如， <code>Open</code> 将会在命名空间 <code>Foo::Bar</code> 中。</p>
</li>
<li>
<p>在 <strong>C#</strong> 中包名被转化为 PascalCase 后被用做命名空间，除非你在你的 <code>.proto</code> 文件中明确提供了 <code>option csharp_package</code> 选项。
例如， <code>Open</code> 将会在命名空间 <code>Foo.Bar</code> 下。</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_包和名称解析">包和名称解析</h3>
<div class="paragraph">
<p>类型名称解析在 Protocol Buffer 语言中以类似 C++ 的方式工作：首先在最内部的空间中搜寻，然后是次内部的，以此类推，每个包都被认为是其父包的“内部”。
一个开头的“.”（例如， <code>.foo.bar.Baz</code> ）表示从最外部范围开始。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_定义服务">定义服务</h2>
<div class="sectionbody">
<div class="paragraph">
<p>如果你想将你的消息类型用于 RPC（Remote Procedure Call）系统，
你可以在一个 <code>.proto</code> 文件中定义 RPC 服务接口，
之后 Protocol Buffer 编译器将会为你所选的语言生成服务接口的代码和存根（stubs）。
所以，比如，你想定义一个带有一个接收 <code>SearchRequest</code> 并返回一个 <code>SearchResponse</code> 方法的RPC服务，
你可以在你的 <code>.proto</code> 文件中做如下定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="protobuf"><span class="kd">service</span> <span class="n">SearchServer</span> <span class="p">{</span>
  <span class="k">rpc</span> <span class="n">Search</span><span class="p">(</span><span class="n">SearchRequest</span><span class="p">)</span> <span class="k">returns</span> <span class="p">(</span><span class="n">SearchResponse</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>与 Protocol Buffer 一起使用最直接的 RPC 系统是 gRPC：
一个由谷歌开发的语言和平台中立的开源 RPC 系统。
gRPC 对于 Protocol Bufer 非常合适，
并且可以让你通过一个特殊的 Protocol Buffer 编译插件从你的 <code>.proto</code> 文件中直接生成相关的 RPC 代码。</p>
</div>
<div class="paragraph">
<p>如果你不想使用 gRPC，也可以将 Protocol Buffer 和你自己的 RPC 实现一起使用。
你可以在 <a href="https://developers.google.com/protocol-buffers/docs/proto#services">Proto2 语言指南</a> 中看到更多相关信息。</p>
</div>
<div class="paragraph">
<p>还有许多发展中的第三方开元项目在为 Protocol Buffer 开发 RPC 实现。
关于我们已知的项目链接列表，可以查看 <a href="https://github.com/protocolbuffers/protobuf/blob/master/docs/third_party.md">第三方插件 Wiki</a> 页面。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_json_映射">JSON 映射</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Proto3 支持 JSON 中的编码规范，从而让系统间的数据共享变得更加轻松。
下标按类型分类对编码进行了描述：</p>
</div>
<div class="paragraph">
<p>如果 JSON 编码中的数据缺少某个值或者其值为 null，那么在解析到 Protocol Buffer 时会被解析为适当的默认值。
如果某个字段在 Protocol Buffer 中有默认值，那么在在 JSON 编码的数据中默认将其省略来节省空间。
有的实现可能会提供选项一个选项用来 JSON 编码中输出有默认值的字段。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">proto3</th>
<th class="tableblock halign-left valign-top">JSON</th>
<th class="tableblock halign-left valign-top">JSON example</th>
<th class="tableblock halign-left valign-top">Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">message</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">object</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">{"fooBar": v, "g": null, …}</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Generates JSON objects. Message field names are mapped to lowerCamelCase and become JSON object keys. If the json_name field option is specified, the specified value will be used as the key instead. Parsers accept both the lowerCamelCase name (or the one specified by the json_name option) and the original proto field name. null is an accepted value for all field types and treated as the default value of the corresponding field type.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">enum</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">"FOO_BAR"</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The name of the enum value as specified in proto is used. Parsers accept both enum names and integer values.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">map&lt;K,V&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">object</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">{"k": v, …}</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">All keys are converted to strings.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">repeated V</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">array</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[v, …]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">null is accepted as the empty list [].</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true, false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true, false</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">"Hello World!"</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">base64 string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">"YWJjMTIzIT8kKiYoKSctPUB+"</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JSON value will be the data encoded as a string using standard base64 encoding with paddings. Either standard or URL-safe base64 encoding with/without paddings are accepted.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">int32, fixed32, uint32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1, -10, 0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JSON value will be a decimal number. Either numbers or strings are accepted.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">int64, fixed64, uint64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">"1", "-10"</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JSON value will be a decimal string. Either numbers or strings are accepted.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">float, double</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.1, -10.0, 0, "NaN", "Infinity"</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity". Either numbers or strings are accepted. Exponent notation is also accepted.  -0 is considered equivalent to 0.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Any</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">object</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">{"@type": "url", "f": v, … }</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If the Any contains a value that has a special JSON mapping, it will be converted as follows: {"@type": xxx, "value": yyy}. Otherwise, the value will be converted into a JSON object, and the "@type" field will be inserted to indicate the actual data type.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Timestamp</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">"1972-01-01T10:00:20.021Z"</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Uses RFC 3339, where generated output will always be Z-normalized and uses 0, 3, 6 or 9 fractional digits. Offsets other than "Z" are also accepted.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Duration</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">"1.000340012s", "1s"</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Generated output always contains 0, 3, 6, or 9 fractional digits, depending on required precision, followed by the suffix "s". Accepted are any fractional digits (also none) as long as they fit into nano-seconds precision and the suffix "s" is required.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Struct</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">object</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">{ … }</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Any JSON object. See struct.proto.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Wrapper types</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">various types</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2, "2", "foo", true, "true", null, 0, …</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Wrappers use the same representation in JSON as the wrapped primitive type, except that null is allowed and preserved during data conversion and transfer.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">FieldMask</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">"f.fooBar,h"</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">See field_mask.proto.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ListValue</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">array</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[foo, bar, …]</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Value</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">value</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Any JSON value. Check google.protobuf.Value for details.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">NullValue</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">null</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JSON null</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Empty</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">object</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">{}</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An empty JSON object</p></td>
</tr>
</tbody>
</table>
<div class="sect2">
<h3 id="_json_选项">JSON 选项</h3>
<div class="paragraph">
<p>一个 proto3 JSON 实现可能会提供下列选项：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>发出带有默认值的字段</strong> ：为默认值的字段在 proto3 JSON 输出中默认被忽略。
有的实现可能会提供一个配置项来覆盖这一行为并输出字段与其默认值。</p>
</li>
<li>
<p><strong>忽略未知字段</strong> ：Proto3 JSON 解析器默认情况下应该拒绝未知字段，但许多都提供来配置项来忽略未知字段。</p>
</li>
<li>
<p><strong>使用 proto 字段名而不是小驼峰命名</strong> ：默认情况下 proto3 JSON 打印器应该将字段名转换为小驼分并将其用作 JSON 字段名。
有的实现可能会提供一个使用 proto 字段名作为 JSON 字段名的配置项。
Proto3 解析器应该可以接受转换后的小驼分和 proto 字段名两种形式。</p>
</li>
<li>
<p><strong>将枚举值作为整数而不是字符串输出</strong> ：枚举值的名称默认被用于 JSON 输出。
可能会提供一个配置项从而使用数字作为枚举的值。</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</body>
</html>