<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.17">
<title>Protocol Buffers</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href=".asciidoctor/asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href=".asciidoctor/rouge-github.css">
</head>
<body class="article toc2 toc-right">
<div id="header">
<h1>Protocol Buffers</h1>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#_定义一个消息类型">定义一个消息类型</a>
<ul class="sectlevel2">
<li><a href="#_指定字段类型">指定字段类型</a></li>
<li><a href="#_分配字段编号">分配字段编号</a></li>
<li><a href="#_指定字段规则">指定字段规则</a></li>
<li><a href="#_添加更多消息类型">添加更多消息类型</a></li>
<li><a href="#_添加注释">添加注释</a></li>
<li><a href="#_保留字段">保留字段</a></li>
<li><a href="#_你的_proto_文件生成了什么">你的 <code>.proto</code> 文件生成了什么</a></li>
</ul>
</li>
<li><a href="#_标量数据类型">标量数据类型</a></li>
<li><a href="#_默认值">默认值</a></li>
<li><a href="#_枚举">枚举</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="quoteblock">
<blockquote>
Protocol buffers are a language-neutral, platform-neutral extensible mechanism for serializing structured data.
</blockquote>
<div class="attribution">
&#8212; https://developers.google.com/protocol-buffers
</div>
</div>
<div class="paragraph">
<p>本指南讲解了如何使用 Protocol Buffer 语言来构造你的 Protocol Buffer 数据，包含 <code>.proto</code> 文件语法以及如何从你的 <code>.proto</code> 文件生成数据访问类。</p>
</div>
<div class="paragraph">
<p>这是一个参考指南 —— 关于一个使用本文档中介绍的许多特性的引导示例，参见你所选语言的对应 <a href="https://developers.google.com/protocol-buffers/docs/tutorials">教程</a> 。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_定义一个消息类型">定义一个消息类型</h2>
<div class="sectionbody">
<div class="paragraph">
<p>首先我们看一个非常简单的示例。
假如说你想定义一个搜索请求格式，每个搜索请求中包含一个 <em>查询字符串</em> ，搜索结果你感兴趣的 <em>页码</em> ，以及 <em>每页结果数</em> 。
那么你可以使用下面这个 <code>.proto</code> 文件来定义你的消息类型。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="protobuf"><span class="na">syntax</span> <span class="o">=</span> <span class="s">"proto3"</span>

<span class="kd">message</span> <span class="nc">SearchRequest</span> <span class="p">{</span>
	<span class="kt">string</span> <span class="na">query</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int32</span> <span class="na">page_number</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="kt">int32</span> <span class="na">result_per_page</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>文件中的第一行指定了你将使用 <code>proto3</code> 语法：如果你不添加这一行那么 Protocol Buffer 编译器将假设你要使用 <a href="https://developers.google.com/protocol-buffers/docs/proto">proto2</a>。
而且必须是文件中第一个非空行并且非注释的行。</p>
</li>
<li>
<p><code>SearchRequest</code> 消息定义指定了三个字段（名/值对）,每一个字段表示你想要包含在消息中数据的一部分。
每个字段都有名称和类型。</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_指定字段类型">指定字段类型</h3>
<div class="paragraph">
<p>在上面的示例中，每个字段都是 <a href="https://developers.google.com/protocol-buffers/docs/proto3#scalar">标量类型</a>：两个整型（ <code>page_number</code> 和 <code>result_per_page</code> ）和一个字符串（ <code>query</code> ）。
但你也可以为你的字段指定复合类型，包括枚举和其他消息类型。</p>
</div>
</div>
<div class="sect2">
<h3 id="_分配字段编号">分配字段编号</h3>
<div class="paragraph">
<p>正如你所看到的，消息定义中的每个字段都有一个 <strong>唯一编号</strong> 。
这些字段编号用来在 <a href="https://developers.google.com/protocol-buffers/docs/encoding">消息二进制格式</a> 中标识你的字段，并且当你的消息类型使用之后就不应再更改它们了。
需要注意的是在范围 1 到 15 的字段编号编码时消耗 1 字节，其中包括字段编号和字段类型（你可以在 <a href="https://developers.google.com/protocol-buffers/docs/encoding#structure">Protocol Buffer 编码</a> 中得到更多相关信息）
范围 16 到 2047 的字段号占用两个字节。
所以你应该为非常频繁出现的字段保留 1 到 15 的字段编号。
并且还要记得为未来可能频繁出现的元素留出一些空间。</p>
</div>
<div class="paragraph">
<p>可以使用的最小字段编号是 1，最大是 2<sup>29</sup> - 1，或 5,3687,0911。
另外你也不能使用 19000 到 19999 的编号（ <code>FieldDescriptor::kFirstReservedNumber</code> 到 <code>FieldDescriptor::kLastReservedNumber</code> ），因为他们是为 Protocol Buffers 实现保留的 —— 如果你在 <code>.proto</code> 文件中使用了其中任意编号编译器将报错。
同样，你也不能使用之前 <a href="https://developers.google.com/protocol-buffers/docs/proto3#reserved">保留</a> 的字段编号。</p>
</div>
</div>
<div class="sect2">
<h3 id="_指定字段规则">指定字段规则</h3>
<div class="paragraph">
<p>消息字段可以是以下两种之一：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>单一：一个符合语法的消息可以包含零个或一个此类字段（但是不能超过一个）。
并且这是 <code>proto3</code> 默认的语法规则。</p>
</li>
<li>
<p>重复（ <code>repeated</code> ）：这种字段在一个符合语法的消息中可以重复任意次（包括零次）。
重复值的顺序将会被保留。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在 proto3 中，标量数字类型的重复（ <code>repeated</code> ）字段默认使用 <code>packed</code> 编码。
你可以在 <a href="https://developers.google.com/protocol-buffers/docs/encoding#packed">Protocol Buffer Encoding</a> 找到更多 <code>packed</code> 编码的信息。</p>
</div>
</div>
<div class="sect2">
<h3 id="_添加更多消息类型">添加更多消息类型</h3>
<div class="paragraph">
<p>多个消息类型可以定义在单个 <code>.proto</code> 文件中。
如果你定义多个相关消息的话这非常有用 —— 比如，如果你想要定义 <code>SearchResponse</code> 消息类型对应的响应消息格式，你可以将其添加到同一个 <code>.proto</code> 文件中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="protobuf"><span class="kd">message</span> <span class="nc">SearchRequest</span> <span class="p">{</span>
	<span class="kt">string</span> <span class="na">query</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int32</span> <span class="na">page_number</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="kt">int32</span> <span class="na">result_per_page</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">message</span> <span class="nc">SearchResponse</span> <span class="p">{</span>
 <span class="o">...</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_添加注释">添加注释</h3>
<div class="paragraph">
<p>要在你的 <code>.proto</code> 文件中添加注释，可以使用 C/C++ 风格的 <code>//</code> 和 <code>/**/</code> 语法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="protobuf"><span class="cm">/* SearchRequest represents a search query, with pagination optionsto
 * indicate wich results to include in the response. */</span>

 <span class="kd">message</span> <span class="nc">SearchRequest</span> <span class="p">{</span>
   <span class="kt">string</span> <span class="na">query</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
   <span class="kt">int32</span> <span class="na">page_number</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>  <span class="c1">// Which page number do we want?</span>
   <span class="kt">int32</span> <span class="na">result_per_page</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// Number of results to return per page.</span>
 <span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_保留字段">保留字段</h3>
<div class="paragraph">
<p>如果你通过完全删除或注释掉某个字段来更新更新一个消息类型，未来的用户可以在对自己的类型进行更新后重新使用这个字段。
如果他们以后再使用同一 <code>.proto</code> 文件的旧版本，会导致非常严重的问题，包括数据损坏，隐私问题等等。
确保这种情况不会发生的一种方法是将你删掉的字段编号（和/或字段名，这会导致 JSON 序列化出现问题）指定为保留（ <code>reserved</code> ）字段。
如果未来的任何用户尝试使用此字段标识，Protocol Buffer 编译器将会报错。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="protobuf"><span class="kd">message</span> <span class="nc">Foo</span> <span class="p">{</span>
  <span class="n">reserved</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">9</span> <span class="k">to</span> <span class="mi">11</span><span class="p">;</span>
  <span class="n">reserved</span> <span class="s">"foo"</span><span class="p">,</span> <span class="s">"bar"</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>注意你不能在同一个 <code>reserved</code> 语句中混用字段名称和字段编号。</p>
</div>
</div>
<div class="sect2">
<h3 id="_你的_proto_文件生成了什么">你的 <code>.proto</code> 文件生成了什么</h3>
<div class="paragraph">
<p>当你使用 <a href="https://developers.google.com/protocol-buffers/docs/proto3#generating">Protocol Buffer 编译器</a> 编译 <code>.proto</code> 文件时，
编译器将根据你选择的语言生成代码，你要使用文件中描述的消息类型，包括获取和设置字段的值、将消息序列化为输出流，以及从输入流中解析消息。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>对于 <strong>C++</strong> ，编译器从每个 <code>.proto</code> 文件生成 <code>.h</code> 和 <code>.cc</code> 文件，并为文件中定义的每个消息类型提供一个类。</p>
</li>
<li>
<p>对于 <strong>Java</strong> ，编译器生成一个 <code>.java</code> 文件，其中包含每个消息类型的类，以及一个用来创建消息类实例的特殊 <code>Builder</code> 类。</p>
</li>
<li>
<p>对于 <strong>Kotlin</strong> ，除了生成的 Java 代码，编译器为每个消息类型都生成了包含用来简化消息实例创建 DSL 的 <code>.kt</code> 文件。</p>
</li>
<li>
<p>对于 <strong>Python</strong> 略有不同 —— Python 编译器会生成一个模块，其中包含 <code>.proto</code> 文件中每种消息类型的静态描述，这些描述将和元类一起在运行时创建所需的数据访问类。</p>
</li>
<li>
<p>对于 <strong>Go</strong> ，编译器会生成一个 <code>.pb.go</code> 文件，其中包含文件中每种消息的类型。</p>
</li>
<li>
<p>对于 <strong>Ruby</strong> ，编译器会生成一个 <code>.rb</code> 文件，其中包含一个含有你所定义消息类型的模块。</p>
</li>
<li>
<p>对于 <strong>Objective-C</strong> ，编译器为每个 <code>.proto</code> 文件生成一个 <code>pbobjc.h</code> 和 <code>pbobjc.m</code> 文件，并为你文件中描述的每种消息类型提供一个类。</p>
</li>
<li>
<p>对于 <strong>C#</strong> ，编译器为每个 <code>.proto</code> 文件生成一个 <code>.cs</code> 文件，为文件中描述的每种消息类型提供一个类。</p>
</li>
<li>
<p>对于 <strong>Dart</strong> ，编译器会生成一个 <code>.pb.dart</code> 文件，其中包含你所定义的每个消息类型的类。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>你可以按照你所选语言的教程（proto3 版本即将推出）了解有关使用每种语言的API的更多信息。
有关 API 的更多详细信息，请参阅相关 <a href="https://developers.google.com/protocol-buffers/docs/reference/overview">API 参考文献</a> (同样 proto3 版本即将推出)。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_标量数据类型">标量数据类型</h2>
<div class="sectionbody">
<div class="paragraph">
<p>一个标量消息字段可以又有下列类型之一 —— 下表现实了 <code>.proto</code> 文件中指定的类型，以及生成类中对应的类型：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 10%;">
<col style="width: 10%;">
<col style="width: 10%;">
<col style="width: 10%;">
<col style="width: 10%;">
<col style="width: 10%;">
<col style="width: 10%;">
<col style="width: 10%;">
<col style="width: 10%;">
<col style="width: 10%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">.proto Type</th>
<th class="tableblock halign-left valign-top">Notes</th>
<th class="tableblock halign-left valign-top">C++ Type</th>
<th class="tableblock halign-left valign-top">Java/Kotlin Type <a href="#_1"><sup>[1]</sup></a></th>
<th class="tableblock halign-left valign-top">Python Type<a href="#_3"><sup>[3]</sup></a></th>
<th class="tableblock halign-left valign-top">Go Type</th>
<th class="tableblock halign-left valign-top">Ruby Type</th>
<th class="tableblock halign-left valign-top">C# Type</th>
<th class="tableblock halign-left valign-top">PHP Type</th>
<th class="tableblock halign-left valign-top">Dart Type</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">float</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">float64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Float</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">float</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">float</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">float</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">float</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">float</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">float32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Float</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">float</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">float</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">int32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint32 instead.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Fixnum or Bignum (as required)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">integer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">int64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint64 instead.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int/long<a href="#_4"><sup>[4]</sup></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bignum</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">integer/string<a href="#_6"><sup>[6]</sup></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Int64</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">uint32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Uses variable-length encoding.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">uint32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int<a href="#_2"><sup>[2]</sup></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int/long<a href="#_4"><sup>[4]</sup></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">uint32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Fixnum or Bignum (as required)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">uint</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">integer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">uint64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Uses variable-length encoding.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">uint64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">long<a href="#_2"><sup>[2]</sup></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int/long<a href="#_4"><sup>[4]</sup></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">uint64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bignum</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ulong</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">integer/string<a href="#_6"><sup>[6]</sup></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Int64</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">sint32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Fixnum or Bignum (as required)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">integer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">sint64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int/long<a href="#_4"><sup>[4]</sup></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bignum</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">integer/string<a href="#_6"><sup>[6]</sup></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Int64</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">fixed32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Always four bytes. More efficient than uint32 if values are often greater than 228.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">uint32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int<a href="#_2"><sup>[2]</sup></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int/long<a href="#_4"><sup>[4]</sup></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">uint32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Fixnum or Bignum (as required)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">uint</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">integer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">fixed64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Always eight bytes. More efficient than uint64 if values are often greater than 256.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">uint64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">long<a href="#_2"><sup>[2]</sup></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int/long<a href="#_4"><sup>[4]</sup></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">uint64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bignum</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ulong</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">integer/string<a href="#_6"><sup>[6]</sup></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Int64</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">sfixed32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Always four bytes.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Fixnum or Bignum (as required)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">integer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">sfixed64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Always eight bytes.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int/long<a href="#_4"><sup>[4]</sup></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bignum</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">integer/string<a href="#_6"><sup>[6]</sup></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Int64</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">boolean</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TrueClass/FalseClass</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">boolean</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A string must always contain UTF-8 encoded or 7-bit ASCII text, and cannot be longer than 232.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">str/unicode<a href="#_5"><sup>[5]</sup></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String (UTF-8)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">May contain any arbitrary sequence of bytes no longer than 232.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ByteString</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">str (Python 2)bytes (Python 3)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[]byte</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String (ASCII-8BIT)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ByteString</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">List</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>当你使用 <a href="https://developers.google.com/protocol-buffers/docs/encoding">Protocol Buffer Encoding</a> 序列化你的消息时，你可以在这里找到更多有关类型编码的信息。</p>
</div>
<div id="_1" class="paragraph">
<p><sup>[1]</sup> Kotlin 使用对应的 Java 类型，甚至无符号类型也和 Java 保持一致，来确保与 Java 代码混用时的兼容性。</p>
</div>
<div id="_2" class="paragraph">
<p><sup>[2]</sup> 在 Java 中，无符号 32 位和 64 位整数使用对应的有符号表示，最高位简单的存储在最高位中。</p>
</div>
<div id="_3" class="paragraph">
<p><sup>[3]</sup> 在所有情况下，位字段赋值都将会执行类型检查来确保值的有效性。</p>
</div>
<div id="_4" class="paragraph">
<p><sup>[4]</sup> 64 位或无符号 32 位整数在解码时始终表示为长整型，但当位字段赋值时如果需要整型则可以是整型 。
在任何情况下，设置的值应该与表示的类型相匹配。</p>
</div>
<div id="_5" class="paragraph">
<p><sup>[5]</sup> Python 字符串在解码是表示位 unicode 但如果是一个 ASCII 字符串也可以表示位 str</p>
</div>
<div id="_6" class="paragraph">
<p><sup>[6]</sup> 整型使用于 64 位机器上，string 用在 32 位机器上。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_默认值">默认值</h2>
<div class="sectionbody">
<div class="paragraph">
<p>当一个消息被解析后，如果解码后的消息不包含某些单例元素，解析后对象中对应的值将被设置为此字段的默认值。
默认值是特定于类型的：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>对于字符串，默认值是空字符串。</p>
</li>
<li>
<p>对于字节，默认值是空字节。</p>
</li>
<li>
<p>对于布尔值，默认值是 false。</p>
</li>
<li>
<p>对于数值类型，默认值是零。</p>
</li>
<li>
<p>对于 <a href="https://developers.google.com/protocol-buffers/docs/proto3#enum">枚举</a>类型，默认值是 <strong>定义的首个枚举值</strong> ，其必须为 0。</p>
</li>
<li>
<p>对一消息类型，该字段没有设置。确切的值于语言相关。详见 <a href="https://developers.google.com/protocol-buffers/docs/reference/overview">代码生成指南</a>。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>重复字段的默认值为空（通常是对应语言中的空值）</p>
</div>
<div class="paragraph">
<p>对于消息中的标量字段需要注意，消息一经解析就再也无法得知一个字段是显式设置为默认值（例如对于布尔值将设置为 <code>false</code> ）还是直接没有设置：
当你定义消息类型时这一点你应该铭记于心。
所以，当你不希望某些行为默认发生时，不要使用布尔值来切换某些行为。
同时注意如果标量消息字段设置为其默认值时，这个值将不会被序列化。</p>
</div>
<div class="paragraph">
<p>查看你选择语言的 <a href="https://developers.google.com/protocol-buffers/docs/reference/overview">代码生成指南</a>获得更多关于生成的代码中默认值的工作细节。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_枚举">枚举</h2>
<div class="sectionbody">
<div class="paragraph">
<p>当你定义一个消息类型时，你可能希望其中一个字段的值是一个预定义列表中某一个值。
例如，假设你想要为每个 <code>SearchRequest</code> 添加一个 <code>corpus</code> 字段，这里 corpus 可以是 <code>UNIVERSAL</code> ， <code>WEB</code> ， <code>IMAGES</code> ， <code>LOCAL</code> ， <code>NEWS</code> ， <code>PRODUCTS</code> 或 <code>VIDEO</code> 。
这可以通过在你定义的消息中添加一个包含每种可能常量值的 <code>enum</code>  轻松搞定。</p>
</div>
<div class="paragraph">
<p>下面的示例中我们添加了一个名为 <code>Corpus</code> 的 <code>enum</code> 以及一个类型为 <code>Corpus</code> 的字段：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="protobuf"><span class="kd">message</span> <span class="nc">SearchRequest</span> <span class="p">{</span>
  <span class="kt">string</span> <span class="na">query</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">int32</span> <span class="na">page_number</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="kt">int32</span> <span class="na">result_per_page</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
  <span class="kd">enum</span> <span class="n">Corpus</span> <span class="p">{</span>
    <span class="na">UNIVERSAL</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="na">WEB</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="na">IMAGES</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="na">LOCAL</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="na">NEWS</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="na">PRODUCTS</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="na">VIDEO</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">Corpus</span> <span class="na">corpus</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</body>
</html>