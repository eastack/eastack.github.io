<!DOCTYPE html>
<html lang="zh-Hans">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.17">
<meta name="author" content="Wang Heng">
<link rel="icon" type="image/x-icon" href="/favicon.ico">
<title>什么是 REST ？</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href=".asciidoctor/asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>什么是 REST ？</h1>
<div class="details">
<span id="author" class="author">Wang Heng</span><br>
<span id="email" class="email"><a href="mailto:admin@eastack.me">admin@eastack.me</a></span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#_rest_指导原则">REST 指导原则</a>
<ul class="sectlevel2">
<li><a href="#_统一接口">统一接口</a></li>
<li><a href="#_客户端_服务器">客户端-服务器</a></li>
<li><a href="#_无状态">无状态</a></li>
<li><a href="#_可缓存">可缓存</a></li>
<li><a href="#_分层系统">分层系统</a></li>
<li><a href="#_按需编码可选">按需编码（可选）</a></li>
</ul>
</li>
<li><a href="#_什么是资源">什么是资源？</a>
<ul class="sectlevel2">
<li><a href="#_资源标识符">资源标识符</a></li>
<li><a href="#_超媒体">超媒体</a></li>
<li><a href="#_自描述">自描述</a></li>
</ul>
</li>
<li><a href="#_资源方法">资源方法</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>REST 是 <strong>RE</strong>presentational <strong>S</strong>tate <strong>T</strong>ransfer 的首字母缩写，它是一种分布式超媒体系统的架构风格。
Roy Fielding 在其 2000 年的著名论文中首次提到了它。</p>
</div>
<div class="paragraph">
<p>与其他架构风格一样，REST有他的指导原则和限制。
如果要将服务接口称为 RESTful 的，那么必须满足这些原则。</p>
</div>
<div class="quoteblock">
<blockquote>
遵循 REST 架构风格的 Web API（或 Web 服务）是 REST API。
</blockquote>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_rest_指导原则">REST 指导原则</h2>
<div class="sectionbody">
<div class="paragraph">
<p>RESTful 架构的六个指导原则或限制是：</p>
</div>
<div class="sect2">
<h3 id="_统一接口">统一接口</h3>
<div class="paragraph">
<p>通过将通用性原则应用于组件接口，我们可以简化整个系统的架构并提高可见性和交互性。</p>
</div>
<div class="paragraph">
<p>多个架构约束有助于获得统一的接口并引导组件组件的行为。</p>
</div>
<div class="paragraph">
<p>以下四个约束可以实现统一的 REST 接口：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>资源标识</strong> —— 接口必须唯一标识客户端和服务器交互中的每个资源。</p>
</li>
<li>
<p><strong>通过表述操作资源</strong> —— 资源在服务器响应中应该有统一的表述。
API 的使用者应该使用这些表述来修改服务器中资源的状态。</p>
</li>
<li>
<p><strong>自描述消息</strong> —— 每个资源表述应该携带足够的信息来描述如何处理消息。
它还应该提供客户端可对资源执行的附加操作的信息。</p>
</li>
<li>
<p><strong>超媒体作为应用程序状态的引擎</strong> —— 客户端应该只有应用程序的初始 URI。
客户端应用程序应该使用超链接动态驱动所有其他资源和交互。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_客户端_服务器">客户端-服务器</h3>
<div class="paragraph">
<p>客户端-服务器设计模式强制执行了<strong>关注点分离</strong>，这有助于客户端和服务器组件独立演进。</p>
</div>
<div class="paragraph">
<p>通过将用户界面关注点（客户端）和数据存储关注点（服务器）分离，
我们提高了用户界面跨多个平台的可移植性，通过简化服务器组件来提高可扩展性。</p>
</div>
<div class="paragraph">
<p>在客户端和服务端演进时，我们确保客户端和服务端之间的接口/契约不被破坏。</p>
</div>
</div>
<div class="sect2">
<h3 id="_无状态">无状态</h3>
<div class="paragraph">
<p>无状态要求从客户端到服务器的每个请求都必须必须包含理解和完成请求所需的所有信息</p>
</div>
<div class="paragraph">
<p>服务器无法利用任何服务器上之前存储的任何上下文信息。</p>
</div>
<div class="paragraph">
<p>因此，客户端程序必须完全保持会话状态。</p>
</div>
</div>
<div class="sect2">
<h3 id="_可缓存">可缓存</h3>
<div class="paragraph">
<p>可缓存约束要求响应应该隐式或显式的标记自己为可缓存或不可缓存的。</p>
</div>
<div class="paragraph">
<p>如果响应是可缓存的，那么客户端有权力在稍后为指定时间段内的等效请求重用响应数据。</p>
</div>
</div>
<div class="sect2">
<h3 id="_分层系统">分层系统</h3>
<div class="paragraph">
<p>分层系统风格允许通过限制组件行为来由层次结构成整体架构。</p>
</div>
<div class="paragraph">
<p>例如在分层系统中，每个组件无法看到与他们交互的密接层之外。</p>
</div>
</div>
<div class="sect2">
<h3 id="_按需编码可选">按需编码（可选）</h3>
<div class="paragraph">
<p>REST 还允许客户端通过小程序或脚本的形式下载和执行代码来扩展客户端的功能。</p>
</div>
<div class="paragraph">
<p>下载的代码通过减少需要预先实现的功能数量来简化客户端。
服务器可以将部分功能以代码的形式交付给客户端，客户端只需要执行这性这些代码。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_什么是资源">什么是资源？</h2>
<div class="sectionbody">
<div class="paragraph">
<p>REST 中关键的<strong>信息的抽象</strong>是资源。</p>
</div>
<div class="paragraph">
<p>我们可以命名的任何信息都可以是资源。
例如，一个 REST 资源可以是一个文档或图片，时间服务，一个其他资源的集合或非虚拟对象（比如：一个人）。</p>
</div>
<div class="paragraph">
<p>资源在任何时间的特定状态被称为资源表述。</p>
</div>
<div class="paragraph">
<p>资源表述包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>数据</strong></p>
</li>
<li>
<p>描述数据的<strong>元数据</strong></p>
</li>
<li>
<p>以及可以帮助客户端转换到下一个所需状态的超媒体链接。</p>
</li>
</ul>
</div>
<div class="quoteblock">
<blockquote>
一个 REST API 由一组相关联的资源构成。
这些资源集合又被称为 REST API <strong>资源模型</strong>。
</blockquote>
</div>
<div class="sect2">
<h3 id="_资源标识符">资源标识符</h3>
<div class="paragraph">
<p>REST 使用资源标识符来识别客户端和服务端组件间交互中涉及的每个资源。</p>
</div>
</div>
<div class="sect2">
<h3 id="_超媒体">超媒体</h3>
<div class="paragraph">
<p>表述的数据格式被称为媒体类型。
媒体类型确定了一个表述如何被处理的规范。</p>
</div>
<div class="paragraph">
<p><strong>一个RESTful API 看起来像 <a href="https://restfulapi.net/hateoas/">超文本</a></strong>。
每个可寻址的信息单元都带有一个地址，或显式（例如：链接和 id 属性）或隐士（例如：从媒体类型定义和表述结构派生）。</p>
</div>
<div class="quoteblock">
<blockquote>
超文本（或超媒体）意味着<strong>同时提供信息和控制项</strong>，因此使信息成为了用户（或自动机）获得选择和执行动作的启示。
</blockquote>
<div class="attribution">
&#8212; Roy Fielding
</div>
</div>
<div class="paragraph">
<p>切记，超文本在浏览器上不需要是 HTML（或 XML 或 JSON）。
当机器了解数据格式和关联类型时，它们可以跟随链接。</p>
</div>
</div>
<div class="sect2">
<h3 id="_自描述">自描述</h3>
<div class="paragraph">
<p>另外，<strong>资源表述应该是自描述的</strong>：客户端不需要知道资源是员工还是设备。
它应该根据与资源关联的媒体类型进行操作。</p>
</div>
<div class="paragraph">
<p>所以在实践中，我们将创建许多 <strong>自定义媒体类型</strong> —— 通常一个媒体类型与一个资源相关联。</p>
</div>
<div class="paragraph">
<p>每个媒体类型都定义了一个默认处理模型。
例如，HTML 定义了超文本渲染过程以及围绕每个元素的浏览器行为。</p>
</div>
<div class="quoteblock">
<blockquote>
媒体类型与资源方法 GET/PUT/POST/DELETE/…等没有关系，除了一些媒体类型元素会定义一个流程模型，如下所示
“有 <strong>href</strong> 属性的矛点元素会创建一个超链接，当被选中时，会调用对应 <strong>CDATA</strong> 编码 <strong>href</strong> 属性的检索请求（GET）。”
</blockquote>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_资源方法">资源方法</h2>
<div class="sectionbody">
<div class="paragraph">
<p>与 REST 相关的另一件重要事情是<strong>资源方法</strong>。
这些资源方法用于在任何资源的两种状态之间执行所需的转换。</p>
</div>
<div class="paragraph">
<p>很多人错误的将资源方法与 <a href="https://restfulapi.net/http-methods/">HTTP方法</a>关联（例如，GET/PUT/POST/DELETE）。
Roy Fielding 从来没提过任何关于在那种条件下使用那种方法的建议。
他所强调的是这应该是一个统一的接口。</p>
</div>
<div class="paragraph">
<p>例如，如果我们决定应用程序 API 将使用 HTTP PSOT 来更新资源 —— 而不是多数人推荐的 HTTP PUT —— 这也没有问题。
尽管这样，API 仍然是 RESTful 的。</p>
</div>
<div class="paragraph">
<p>理想情况下，转换资源状态所需的一切都应该是资源表述的一部分 —— 包括所有支持的方法以及他们将以何种形式离开表述。</p>
</div>
<div class="quoteblock">
<blockquote>
We should enter a REST API with no prior knowledge beyond the initial URI (a bookmark) and a set of standardized media types appropriate for the intended audience (i.e., expected to be understood by any client that might use the API).
</blockquote>
</div>
</div>
</div>
</div>
</body>
</html>