= Protocol Buffers
:toc: right

[quote, https://developers.google.com/protocol-buffers]
Protocol buffers are a language-neutral, platform-neutral extensible mechanism for serializing structured data.

本指南讲解了如何使用 Protocol Buffer 语言来构造你的 Protocol Buffer 数据，包含 `.proto` 文件语法以及如何从你的 `.proto` 文件生成数据访问类。

这是一个参考指南 —— 关于一个使用本文档中介绍的许多特性的引导示例，参见你所选语言的对应 https://developers.google.com/protocol-buffers/docs/tutorials[教程] 。

== 定义一个消息类型

首先我们看一个非常简单的示例。
假如说你想定义一个搜索请求格式，每个搜索请求中包含一个 _查询字符串_ ，搜索结果你感兴趣的 _页码_ ，以及 _每页结果数_ 。
那么你可以使用下面这个 `.proto` 文件来定义你的消息类型。

[source, protobuf]
----
syntax = "proto3"

message SearchRequest {
	string query = 1;
	int32 page_number = 2;
	int32 result_per_page = 3;
}
----

* 文件中的第一行指定了你将使用 `proto3` 语法：如果你不添加这一行那么 Protocol Buffer 编译器将假设你要使用 https://developers.google.com/protocol-buffers/docs/proto[proto2]。
而且必须是文件中第一个非空行并且非注释的行。
* `SearchRequest` 消息定义指定了三个字段（名/值对）,每一个字段表示你想要包含在消息中数据的一部分。
每个字段都有名称和类型。

=== 指定字段类型

在上面的示例中，每个字段都是 https://developers.google.com/protocol-buffers/docs/proto3#scalar[标量类型]：两个整型（ `page_number` 和 `result_per_page` ）和一个字符串（ `query` ）。
但你也可以为你的字段指定复合类型，包括枚举和其他消息类型。

=== 分配字段编号

正如你所看到的，消息定义中的每个字段都有一个 *唯一编号* 。
这些字段编号用来在 https://developers.google.com/protocol-buffers/docs/encoding[消息二进制格式] 中标识你的字段，并且当你的消息类型使用之后就不应再更改它们了。
需要注意的是在范围 1 到 15 的字段编号编码时消耗 1 字节，其中包括字段编号和字段类型（你可以在 https://developers.google.com/protocol-buffers/docs/encoding#structure[Protocol Buffer 编码] 中得到更多相关信息）
范围 16 到 2047 的字段号占用两个字节。
所以你应该为非常频繁出现的字段保留 1 到 15 的字段编号。
并且还要记得为未来可能频繁出现的元素留出一些空间。

可以使用的最小字段编号是 1，最大是 2^29^ - 1，或 5,3687,0911。 
另外你也不能使用 19000 到 19999 的编号（ `FieldDescriptor::kFirstReservedNumber` 到 `FieldDescriptor::kLastReservedNumber` ），因为他们是为 Protocol Buffers 实现保留的 —— 如果你在 `.proto` 文件中使用了其中任意编号编译器将报错。
同样，你也不能使用之前 https://developers.google.com/protocol-buffers/docs/proto3#reserved[保留] 的字段编号。

=== 指定字段规则

消息字段可以是以下两种之一：

* 单一：一个符合语法的消息可以包含零个或一个此类字段（但是不能超过一个）。
并且这是 `proto3` 默认的语法规则。
* 重复（ `repeated` ）：这种字段在一个符合语法的消息中可以重复任意次（包括零次）。
重复值的顺序将会被保留。

在 proto3 中，标量数字类型的重复（ `repeated` ）字段默认使用 `packed` 编码。
你可以在 https://developers.google.com/protocol-buffers/docs/encoding#packed[Protocol Buffer Encoding] 找到更多 `packed` 编码的信息。

=== 添加更多消息类型

多个消息类型可以定义在单个 `.proto` 文件中。
如果你定义多个相关消息的话这非常有用 —— 比如，如果你想要定义 `SearchResponse` 消息类型对应的响应消息格式，你可以将其添加到同一个 `.proto` 文件中：

[source, protobuf]
----
message SearchRequest {
	string query = 1;
	int32 page_number = 2;
	int32 result_per_page = 3;
}

message SearchResponse {
 ...
}
----

=== 添加注释

要在你的 `.proto` 文件中添加注释，可以使用 C/C++ 风格的 `//` 和 `/**/` 语法。
[source, protobuf]
----
/* SearchRequest represents a search query, with pagination optionsto
 * indicate wich results to include in the response. */

 message SearchRequest {
   string query = 1,
   int32 page_number = 2;  // Which page number do we want?
   int32 result_per_page = 3; // Number of results to return per page.
 }
----

=== 保留字段

如果你通过完全删除或注释掉某个字段来更新更新一个消息类型，未来的用户可以在对自己的类型进行更新后重新使用这个字段。
如果他们以后再使用同一 `.proto` 文件的旧版本，会导致非常严重的问题，包括数据损坏，隐私问题等等。
确保这种情况不会发生的一种方法是将你删掉的字段编号（和/或字段名，这会导致 JSON 序列化出现问题）指定为保留（ `reserved` ）字段。
如果未来的任何用户尝试使用此字段标识，Protocol Buffer 编译器将会报错。

[source, protobuf]
----
message Foo {
  reserved 2, 15, 9 to 11;
  reserved "foo", "bar";
}
----

注意你不能在同一个 `reserved` 语句中混用字段名称和字段编号。

=== 你的 `.proto` 文件生成了什么

当你使用 https://developers.google.com/protocol-buffers/docs/proto3#generating[Protocol Buffer 编译器] 编译 `.proto` 文件时，
编译器将根据你选择的语言生成代码，你要使用文件中描述的消息类型，包括获取和设置字段的值、将消息序列化为输出流，以及从输入流中解析消息。

* 对于 *C++* ，编译器从每个 `.proto` 文件生成 `.h` 和 `.cc` 文件，并为文件中定义的每个消息类型提供一个类。
* 对于 *Java* ，编译器生成一个 `.java` 文件，其中包含每个消息类型的类，以及一个用来创建消息类实例的特殊 `Builder` 类。
* 对于 *Kotlin* ，除了生成的 Java 代码，编译器为每个消息类型都生成了包含用来简化消息实例创建 DSL 的 `.kt` 文件。
* 对于 *Python* 略有不同 —— Python 编译器会生成一个模块，其中包含 `.proto` 文件中每种消息类型的静态描述，这些描述将和元类一起在运行时创建所需的数据访问类。
* 对于 *Go* ，编译器会生成一个 `.pb.go` 文件，其中包含文件中每种消息的类型。
* 对于 *Ruby* ，编译器会生成一个 `.rb` 文件，其中包含一个含有你所定义消息类型的模块。
* 对于 *Objective-C* ，编译器为每个 `.proto` 文件生成一个 `pbobjc.h` 和 `pbobjc.m` 文件，并为你文件中描述的每种消息类型提供一个类。
* 对于 *C#* ，编译器为每个 `.proto` 文件生成一个 `.cs` 文件，为文件中描述的每种消息类型提供一个类。
* 对于 *Dart* ，编译器会生成一个 `.pb.dart` 文件，其中包含你所定义的每个消息类型的类。

你可以按照你所选语言的教程（proto3 版本即将推出）了解有关使用每种语言的API的更多信息。
有关 API 的更多详细信息，请参阅相关 https://developers.google.com/protocol-buffers/docs/reference/overview[API 参考文献] (同样 proto3 版本即将推出)。

== 标量数据类型

一个标量消息字段可以又有下列类型之一 —— 下表现实了 `.proto` 文件中指定的类型，以及生成类中对应的类型：
|===
|.proto Type|Notes|C++ Type|Java/Kotlin Type <<_1, ^[1]^>>|Python Type<<_3, ^[3]^>>|Go Type|Ruby Type|C# Type|PHP Type|Dart Type

|double||double|double|float|float64|Float|double|float|double
|float||float|float|float|float32|Float|float|float|double
|int32|Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint32 instead.|int32|int|int|int32|Fixnum or Bignum (as required)|int|integer|int
|int64|Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint64 instead.|int64|long|int/long<<_4, ^[4]^>>|int64|Bignum|long|integer/string<<_6, ^[6]^>>|Int64
|uint32|Uses variable-length encoding.|uint32|int<<_2, ^[2]^>>|int/long<<_4, ^[4]^>>|uint32|Fixnum or Bignum (as required)|uint|integer|int
|uint64|Uses variable-length encoding.|uint64|long<<_2, ^[2]^>>|int/long<<_4, ^[4]^>>|uint64|Bignum|ulong|integer/string<<_6, ^[6]^>>|Int64
|sint32|Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s.|int32|int|int|int32|Fixnum or Bignum (as required)|int|integer|int
|sint64|Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s.|int64|long|int/long<<_4, ^[4]^>>|int64|Bignum|long|integer/string<<_6, ^[6]^>>|Int64
|fixed32|Always four bytes. More efficient than uint32 if values are often greater than 228.|uint32|int<<_2, ^[2]^>>|int/long<<_4, ^[4]^>>|uint32|Fixnum or Bignum (as required)|uint|integer|int
|fixed64|Always eight bytes. More efficient than uint64 if values are often greater than 256.|uint64|long<<_2, ^[2]^>>|int/long<<_4, ^[4]^>>|uint64|Bignum|ulong|integer/string<<_6, ^[6]^>>|Int64
|sfixed32|Always four bytes.|int32|int|int|int32|Fixnum or Bignum (as required)|int|integer|int
|sfixed64|Always eight bytes.|int64|long|int/long<<_4, ^[4]^>>|int64|Bignum|long|integer/string<<_6, ^[6]^>>|Int64
|bool||bool|boolean|bool|bool|TrueClass/FalseClass|bool|boolean|bool
|string|A string must always contain UTF-8 encoded or 7-bit ASCII text, and cannot be longer than 232.|string|String|str/unicode<<_5, ^[5]^>>|string|String (UTF-8)|string|string|String
|bytes|May contain any arbitrary sequence of bytes no longer than 232.|string|ByteString|str (Python 2)bytes (Python 3)|[]byte|String (ASCII-8BIT)|ByteString|string|List
|===

当你使用 https://developers.google.com/protocol-buffers/docs/encoding[Protocol Buffer Encoding] 序列化你的消息时，你可以在这里找到更多有关类型编码的信息。

[#_1]
^[1]^ Kotlin 使用对应的 Java 类型，甚至无符号类型也和 Java 保持一致，来确保与 Java 代码混用时的兼容性。

[#_2]
^[2]^ 在 Java 中，无符号 32 位和 64 位整数使用对应的有符号表示，最高位简单的存储在最高位中。

[#_3]
^[3]^ 在所有情况下，位字段赋值都将会执行类型检查来确保值的有效性。

[#_4]
^[4]^ 64 位或无符号 32 位整数在解码时始终表示为长整型，但当位字段赋值时如果需要整型则可以是整型 。
在任何情况下，设置的值应该与表示的类型相匹配。

[#_5]
^[5]^ Python 字符串在解码是表示位 unicode 但如果是一个 ASCII 字符串也可以表示位 str

[#_6]
^[6]^ 整型使用于 64 位机器上，string 用在 32 位机器上。

== 默认值

当一个消息被解析后，如果解码后的消息不包含某些单例元素，解析后对象中对应的值将被设置为此字段的默认值。
默认值是特定于类型的：

* 对于字符串，默认值是空字符串。
* 对于字节，默认值是空字节。
* 对于布尔值，默认值是 false。
* 对于数值类型，默认值是零。
* 对于 https://developers.google.com/protocol-buffers/docs/proto3#enum[枚举]类型，默认值是 *定义的首个枚举值* ，其必须为 0。
* 对一消息类型，该字段没有设置。确切的值于语言相关。详见 https://developers.google.com/protocol-buffers/docs/reference/overview[代码生成指南]。

重复字段的默认值为空（通常是对应语言中的空值）

对于消息中的标量字段需要注意，消息一经解析就再也无法得知一个字段是显式设置为默认值（例如对于布尔值将设置为 `false` ）还是直接没有设置：
当你定义消息类型时这一点你应该铭记于心。
所以，当你不希望某些行为默认发生时，不要使用布尔值来切换某些行为。
同时注意如果标量消息字段设置为其默认值时，这个值将不会被序列化。 

查看你选择语言的 https://developers.google.com/protocol-buffers/docs/reference/overview[代码生成指南]获得更多关于生成的代码中默认值的工作细节。

== 枚举

当你定义一个消息类型时，你可能希望其中一个字段的值是一个预定义列表中某一个值。
例如，假设你想要为每个 `SearchRequest` 添加一个 `corpus` 字段，这里 corpus 可以是 `UNIVERSAL` ， `WEB` ， `IMAGES` ， `LOCAL` ， `NEWS` ， `PRODUCTS` 或 `VIDEO` 。
这可以通过在你定义的消息中添加一个包含每种可能常量值的 `enum`  轻松搞定。

下面的示例中我们添加了一个名为 `Corpus` 的 `enum` 以及一个类型为 `Corpus` 的字段：
[source, protobuf]
----
message SearchRequest {
  string query = 1;
  int32 page_number = 2;
  int32 result_per_page = 3;
  enum Corpus {
    UNIVERSAL = 0;
    WEB = 1;
    IMAGES = 2;
    LOCAL = 3;
    NEWS = 4;
    PRODUCTS = 5;
    VIDEO = 6;
  }
  Corpus corpus = 4;
}


----
