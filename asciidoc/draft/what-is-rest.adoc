= 什么是 REST ？

REST 是 **RE**presentational **S**tate **T**ransfer 的首字母缩写，它是一种分布式超媒体系统的架构风格。
Roy Fielding 在其 2000 年的著名论文中首次提到了它。

与其他架构风格一样，REST有他的指导原则和限制。
如果要将服务接口称为 RESTful 的，那么必须满足这些原则。

[quote]
遵循 REST 架构风格的 Web API（或 Web 服务）是 REST API。

== REST 指导原则

RESTful 架构的六个指导原则或限制是：

=== 统一接口

通过将通用性原则应用于组件接口，我们可以简化整个系统的架构并提高可见性和交互性。

多个架构约束有助于获得统一的接口并引导组件组件的行为。

以下四个约束可以实现统一的 REST 接口：

* **资源标识** —— 接口必须唯一标识客户端和服务器交互中的每个资源。

* **通过表述操作资源** —— 资源在服务器响应中应该有统一的表述。
API 的使用者应该使用这些表述来修改服务器中资源的状态。

* **自描述消息** —— 每个资源表述应该携带足够的信息来描述如何处理消息。
它还应该提供客户端可对资源执行的附加操作的信息。

* **超媒体作为应用程序状态的引擎** —— 客户端应该只有应用程序的初始 URI。
客户端应用程序应该使用超链接动态驱动所有其他资源和交互。

=== 客户端-服务器

客户端-服务器设计模式强制执行了**关注点分离**，这有助于客户端和服务器组件独立演进。

通过将用户界面关注点（客户端）和数据存储关注点（服务器）分离，
我们提高了用户界面跨多个平台的可移植性，通过简化服务器组件来提高可扩展性。

在客户端和服务端演进时，我们确保客户端和服务端之间的接口/契约不被破坏。

=== 无状态

无状态要求从客户端到服务器的每个请求都必须必须包含理解和完成请求所需的所有信息

服务器无法利用任何服务器上之前存储的任何上下文信息。

因此，客户端程序必须完全保持会话状态。

=== 可缓存

可缓存约束要求响应应该隐式或显式的标记自己为可缓存或不可缓存的。

如果响应是可缓存的，那么客户端有权力在稍后为指定时间段内的等效请求重用响应数据。

===  分层系统

分层系统风格允许通过限制组件行为来由层次结构成整体架构。

例如在分层系统中，每个组件无法看到与他们交互的密接层之外。

=== 按需编码（可选）

REST 还允许客户端通过小程序或脚本的形式下载和执行代码来扩展客户端的功能。

下载的代码通过减少需要预先实现的功能数量来简化客户端。
服务器可以将部分功能以代码的形式交付给客户端，客户端只需要执行这性这些代码。

== 什么是资源？

REST 中关键的**信息的抽象**是资源。

我们可以命名的任何信息都可以是资源。
例如，一个 REST 资源可以是一个文档或图片，时间服务，一个其他资源的集合或非虚拟对象（比如：一个人）。

资源在任何时间的特定状态被称为资源表述。

资源表述包括：

* **数据**
* 描述数据的**元数据**
* 以及可以帮助客户端转换到下一个所需状态的超媒体链接。

[quote]
一个 REST API 由一组相关联的资源构成。
这些资源集合又被称为 REST API **资源模型**。

=== 资源标识符

REST 使用资源标识符来识别客户端和服务端组件间交互中涉及的每个资源。

=== 超媒体

表述的数据格式被称为媒体类型。
媒体类型确定了一个表述如何被处理的规范。

**一个RESTful API 看起来像 https://restfulapi.net/hateoas/[超文本]**。
每个可寻址的信息单元都带有一个地址，或显式（例如：链接和 id 属性）或隐士（例如：从媒体类型定义和表述结构派生）。

[quote, Roy Fielding]
超文本（或超媒体）意味着**同时提供信息和控制项**，因此使信息成为了用户（或自动机）获得选择和执行动作的启示。

切记，超文本在浏览器上不需要是 HTML（或 XML 或 JSON）。
当机器了解数据格式和关联类型时，它们可以跟随链接。

=== 自描述

另外，**资源表述应该是自描述的**：客户端不需要知道资源是员工还是设备。
它应该根据与资源关联的媒体类型进行操作。

所以在实践中，我们将创建许多 *自定义媒体类型* —— 通常一个媒体类型与一个资源相关联。

每个媒体类型都定义了一个默认处理模型。
例如，HTML 定义了超文本渲染过程以及围绕每个元素的浏览器行为。

[quote]
媒体类型与资源方法 GET/PUT/POST/DELETE/…等没有关系，除了一些媒体类型元素会定义一个流程模型，如下所示
“有 *href* 属性的矛点元素会创建一个超链接，当被选中时，会调用对应 *CDATA* 编码 *href* 属性的检索请求（GET）。”

== 资源方法

与 REST 相关的另一件重要事情是**资源方法**。
这些资源方法用于在任何资源的两种状态之间执行所需的转换。

很多人错误的将资源方法与 https://restfulapi.net/http-methods/[HTTP方法]关联（例如，GET/PUT/POST/DELETE）。
Roy Fielding 从来没提过任何关于在那种条件下使用那种方法的建议。
他所强调的是这应该是一个统一的接口。

例如，如果我们决定应用程序 API 将使用 HTTP PSOT 来更新资源 —— 而不是多数人推荐的 HTTP PUT —— 这也没有问题。
尽管这样，API 仍然是 RESTful 的。

理想情况下，转换资源状态所需的一切都应该是资源表述的一部分 —— 包括所有支持的方法以及他们将以何种形式离开表述。

[quote]
We should enter a REST API with no prior knowledge beyond the initial URI (a bookmark) and a set of standardized media types appropriate for the intended audience (i.e., expected to be understood by any client that might use the API).

