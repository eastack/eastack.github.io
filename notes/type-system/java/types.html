<!DOCTYPE html>
<html lang="zh-Hans">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.17">
<title>范型类型</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href=".asciidoctor/asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href=".asciidoctor/rouge-github.css">
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>范型类型</h1>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#_一个简单的包装类型">一个简单的包装类型</a></li>
<li><a href="#_范型版_box_类">范型版 <code>Box</code> 类</a></li>
<li><a href="#_类型参数命名规范">类型参数命名规范</a></li>
<li><a href="#_调用和实例化范型类型">调用和实例化范型类型</a></li>
<li><a href="#_钻石符">钻石符</a></li>
<li><a href="#_多个类型参数">多个类型参数</a></li>
<li><a href="#_参数化类型">参数化类型</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>一个范型类型是一个通过类型参数化的范型类或接口。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_一个简单的包装类型">一个简单的包装类型</h2>
<div class="sectionbody">
<div class="paragraph">
<p>我们先来看一个对任何类型进行操作的非范型类 <code>Box</code> 。
他只需要两个方法，一个 <code>set</code> 它将一个对象添加到box中，一个 <code>get</code> 它将之前设置的对象取回。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Box</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Object</span> <span class="n">object</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="nc">Object</span> <span class="n">object</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">object</span> <span class="o">=</span> <span class="n">object</span><span class="o">;</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">object</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>因为 <code>Box</code> 类的方法接收或返回一个 <code>Object</code> 所以你可以自由的传入任何你想要的东西，只要它不是原始类型之一。
我们在编译时无法验证类的使用方式。
一部分代码可能会在 <code>Box</code> 中存放一个 <code>Integer</code> 并期望从中取回一个 <code>Integer</code> ，但另一部分代码可能错误的传入了一个 <code>String</code> 从而导致运行时错误。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_范型版_box_类">范型版 <code>Box</code> 类</h2>
<div class="sectionbody">
<div class="paragraph">
<p>范型类使用以下格式定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">class</span> <span class="nc">name</span><span class="o">&lt;</span><span class="no">T1</span><span class="o">,</span> <span class="no">T2</span><span class="o">,</span> <span class="o">...,</span> <span class="nc">Tn</span><span class="o">&gt;</span> <span class="o">{</span> <span class="cm">/* ... */</span> <span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>类型参数部分由尖括号（&lt;&gt;）分隔，跟在类名之后。
其指定类型信息（又称类型变量）T1, T2,&#8230;&#8203;,Tn。</p>
</div>
<div class="paragraph">
<p>要更新 <code>Box</code> 类来使用范型，你可以通过将代码 <code>public class Box</code> 改为 <code>public class Box&lt;T&gt;</code> 来创建一个范型类型声明。
这里引入了类型变量 <code>T</code> ，它可以在类中的任何地方使用。</p>
</div>
<div class="paragraph">
<p><code>Box</code> 随着改变， <code>Box</code> 将变为如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="cm">/**
 * Generic version of the Box class.
 * @param &lt;T&gt; the type of the value being boxed
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Box</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="c1">// T stands for "Type"</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">t</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">t</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如你所见，所有的Object出现的地方都被T代替。
类型变量可以是你指定的任何非原始类型：任何接口类型，数组类型，甚至另一个类型变量。</p>
</div>
<div class="paragraph">
<p>同样的技术可以用来创建通用接口。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_类型参数命名规范">类型参数命名规范</h2>
<div class="sectionbody">
<div class="paragraph">
<p>按照惯例，类型参素名称是单个大写字母。
这和你已经知道的命名规范形成鲜明对比，并且这有充分的理由：
如果没有这个规范，将很难将类型变量和普通的类或接口名进行区分。</p>
</div>
<div class="paragraph">
<p>最常用的类型参数名称是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>E - Element(元素，被Java集合框架广泛使用)</p>
</li>
<li>
<p>K - Key</p>
</li>
<li>
<p>N - Number</p>
</li>
<li>
<p>T - Type</p>
</li>
<li>
<p>V - Value</p>
</li>
<li>
<p>S,U,V etc. - 2nd, 3rd, 4th types</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>你将会在Java SE API和本课程的其余部分中看到这些名称。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_调用和实例化范型类型">调用和实例化范型类型</h2>
<div class="sectionbody">
<div class="paragraph">
<p>要从您的代码中使用范型 <code>Box</code> 类你必须执行范型类型调用，其将 <code>T</code> 替换为一些具体的值，比如 <code>Integer</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="nc">Box</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">integerBox</span><span class="o">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以将范型类型调用视为普通方法调用，但不是将参数传递给方法，而是将类型参数（在本里中为 Integer）传递给 Box 类本身。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">NOTE</dt>
<dd>
<p>术语 “Type Parameter" 和 “Type Argument”：许多开发人员交替使用术语 "type parameter" 和 "type argument" ，但这这两个术语并不相同。
当编码时，我们提供一个类型参数(type augument)，来创建一个参数化类型(parameterized type)。
因此， <code>Foo&lt;T&gt;</code> 中的 <code>T</code> 是一个类型参数（type parameter）而在 <code>Foo&lt;String&gt; f</code> 中 <code>String</code> 是一个类型参数（type arguamen）。本课程在使用这些术语时遵守此定义。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>和其他任何变量声明一样，这段代码并没有创建新的 Box 对象。
它只是简单的声明了 integerBox 将会保存对 “Box of Integer” 的引用，这是 `Box&lt;Integer&gt;的阅读方式。</p>
</div>
<div class="paragraph">
<p>范型类型调用通常称为参数化类型。</p>
</div>
<div class="paragraph">
<p>To instantiate this class, use the new keyword, as usual, but place &lt;Integer&gt; between the class name and the parenthesis:
要实例化这个类，可以使用 <code>new</code> 关键字，但将 <code>&lt;Integer&gt;</code> 放在类名和括号之间。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="nc">Box</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">integerBox</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Box</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;();</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_钻石符">钻石符</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在Java SE 7及之后的版本中，只要编译器可以在上下文中确定或推断出类型参数，你就可以将调用范型类的构造函数所需的类型参数替换为空的类型参数集（&lt;&gt;）。
这对尖括号被非正式的称为钻石符。
比如，你可以使用下列语句创建 <code>Box&lt;Integer&gt;</code> 的实例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="nc">Box</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">integerBox</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Box</span><span class="o">&lt;&gt;();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>关于钻石符和类型推断的更多信息，请参阅 <a href="https://docs.oracle.com/javase/tutorial/java/generics/genTypeInference.html">类型推断</a>。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_多个类型参数">多个类型参数</h2>
<div class="sectionbody">
<div class="paragraph">
<p>如之前所述，一个范型类型可以拥有多个类型参数。
比如，范型类 <code>OrderPair</code> ，他实现了范型 <code>Pair</code> 接口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="no">K</span> <span class="nf">getKey</span><span class="o">();</span>
	<span class="kd">public</span> <span class="no">V</span> <span class="nf">getValue</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderedPair</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="no">K</span> <span class="n">key</span><span class="o">;</span>
	<span class="kd">private</span> <span class="no">V</span> <span class="n">value</span><span class="o">;</span>

	<span class="kd">public</span> <span class="nf">OrderedPair</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">,</span> <span class="no">V</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
		<span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="no">K</span> <span class="nf">getKey</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="n">key</span><span class="o">;}</span>
	<span class="kd">public</span> <span class="no">K</span> <span class="nf">getValue</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="n">value</span><span class="o">;}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>下面的语句创建了两个 <code>OrderedPair</code> 类的实例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">OrderedPair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;(</span><span class="s">"Even"</span><span class="o">,</span> <span class="mi">8</span><span class="o">);</span>
<span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">OrderedPair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;(</span><span class="s">"hello"</span><span class="o">,</span> <span class="s">"world"</span><span class="o">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>代码 <code>new OrderedPair&lt;String, Integer&gt;</code> 实例化 <code>K</code> 为 <code>String</code> 、 <code>V</code> 为 <code>Integer</code> 。
因此， <code>OrderPair</code> 的构造函数的参数类型分别是 <code>String</code> 和 <code>Integer</code> 。
由于自动装箱，将 <code>String</code> 和 <code>int</code> 传给此类是有效的。</p>
</div>
<div class="paragraph">
<p>正如前面钻石符中提到的，因为Java编译器可以从OrderedPair&lt;String, Integer&gt; 声明中推断出 K 和 V 类型，所以可以使用钻石表示法缩短这些语句。</p>
</div>
<div class="paragraph">
<p>OrderedPair&lt;String, Integer&gt; p1 = new OrderedPair&lt;&gt;("Even", 8);
OrderedPair&lt;String, String&gt;  p2 = new OrderedPair&lt;&gt;("hello", "world");</p>
</div>
<div class="paragraph">
<p>创建范型接口，遵循与创建范型类同样的约定。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_参数化类型">参数化类型</h2>
<div class="sectionbody">
<div class="paragraph">
<p>你还可以使用参数化类型（如 List&lt;String&gt;这种类型) 替换类型参数（即 K 或者 V）。
比如使用OrderedPair&lt;K, V&gt;举例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="nc">OrderedPair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Box</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">OrderedPair</span><span class="o">&lt;&gt;(</span><span class="s">"primes"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Box</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;(...);</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</body>
</html>