<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.17">
<title>通配符与子类型</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href=".asciidoctor/asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body class="article">
<div id="header">
<h1>通配符与子类型</h1>
</div>
<div id="content">
<div class="paragraph">
<p>如范型，继承，子类型中所述，范型类或接口之间的关系不仅仅因为他们的类型之间存在关系。
但是您可以使用通配符来创建范型类或接口之间的关系。</p>
</div>
<div class="paragraph">
<p>给出以下两个常规（非范型）类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>class A { /* ... */ }
class B extends A { /* ... */ }</pre>
</div>
</div>
<div class="paragraph">
<p>编写一下代码是合理的</p>
</div>
<div class="listingblock">
<div class="content">
<pre>B b = new B();
A a = b;</pre>
</div>
</div>
<div class="paragraph">
<p>示例表明，常规类的继承对子类遵循如下规则：
类B类A的子类型，如果B继承自A。
此规则无法应用于范型类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>List&lt;B&gt; lb = new ArrayList&lt;&gt;();
List&lt;A&gt; la = lb; // compile-time error

鉴于 Integer 是 Number 的子类型，List&lt;Integer&gt; 和 List&lt;Number&gt; 之间的关系是什么？
虽然 Integer 是 Number 的子类型，但 List&lt;Integer&gt; 不是 List&lt;Number&gt; 的子类型，实际上这两种类型没有关系。 List&lt;Number&gt; 和 List&lt;Integer&gt; 的共同父项是 List&lt;?&gt;。</pre>
</div>
</div>
</div>
</body>
</html>