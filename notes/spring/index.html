<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.17">
<title>Spring</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href=".asciidoctor/asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>Spring</h1>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#_请求处理">请求处理</a></li>
<li><a href="#_参数转换">参数转换</a></li>
<li><a href="#_bean的注册和装配wiring">Bean的注册和装配（wiring）</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Spring主要通过DI实现的IOC和AOP配合以下四个原则来助力Java开发。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>基于POJO的轻量级和最小侵入性编程;</p>
</li>
<li>
<p>通过依赖注入和面向接口实现松耦合;</p>
</li>
<li>
<p>基于切面和惯例进行声明式编程;</p>
</li>
<li>
<p>通过切面和模板减少样板式代码;</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>控制反转（IOC:Inversion Of Control）
依赖注入（DI:Dependency Injection）
面向切面编程（AOP:Aspect-Oriented Programming）</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_请求处理">请求处理</h2>
<div class="sectionbody">
<div class="paragraph">
<p>HttpHandler 会在 HttpHandlerAutoConfiguration 中被创建，
之后被org.springframework.boot.web.reactive.context.WebServerManager.DelayedInitializationHttpHandler
包裹后，传入 ReactorHttpHandlerAdapter 使用</p>
</div>
<div class="paragraph">
<p>在 <code>org.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration.AnnotationConfig#httpHandler</code> 中完成了</p>
</div>
<div class="paragraph">
<p>使用 reactor.netty.http.server.HttpServer 将
Spring 中的入口 Handler(org.springframework.http.server.reactive.ReactorHttpHandlerAdapter)
与 Reactor Netty 结合，从而与 Netty 结合</p>
</div>
<div class="paragraph">
<p>Reactor Netty 的 Http Server 中用到的 handler 类型是
BiFunction&lt;? super HttpServerRequest, ? super HttpServerResponse, ? extends Publisher&lt;Void&gt;&gt; handler;</p>
</div>
<div class="paragraph">
<p>请求到来触发了 Reactory Netty 的 reactor.netty.http.server.HttpServer.HttpServerHandle#onStateChange
紧接着在内部调用了
BiFunction&lt;? super HttpServerRequest, ? super HttpServerResponse, ? extends Publisher&lt;Void&gt;&gt; Handler
的 apply</p>
</div>
<div class="paragraph">
<p>而此处使用的 handler 是 Spring 中的 ReactorHttpHandlerAdapter 它实现了这一函数接口。
然后在内部调用了 org.springframework.boot.web.reactive.context.WebServerManager.DelayedInitializationHttpHandler
的 Mono&lt;Void&gt; handle(ServerHttpRequest request, ServerHttpResponse response)</p>
</div>
<div class="paragraph">
<p>如果配置了basePath的话 然后又代理给了 org.springframework.http.server.reactive.ContextPathCompositeHandler，
否则直接到了 org.springframework.web.server.adapter.HttpWebHandlerAdapter#handle
最终 ServerHttpRequest 和 ServerHttpResponse 在这里变为了 ServerWebExchange,
然后所有Handler 也都由 HttpHandler 变为了 WebHandler</p>
</div>
<div class="paragraph">
<p>随后代理给了 org.springframework.web.server.handler.ExceptionHandlingWebHandler
随后通过其实现的 WebHandlerDecorator 代理给了 org.springframework.web.server.handler.FilteringWebHandler
FilteringWebHandler 中又包含了 一个WebFilter的列表和其装饰的 WebHandler，并通过两者创建了
org.springframework.web.server.handler.DefaultWebFilterChain
并开始</p>
</div>
<div class="paragraph">
<p>Spring 通过
org.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryConfiguration.EmbeddedNetty#nettyReactiveWebServerFactory
建立的 Factory 来建立 Reactory Netty 的 WebServer</p>
</div>
<div class="paragraph">
<p>之后又通过 org.springframework.boot.web.reactive.context.WebServerManager#WebServerManager
结合其参数中的 HttpHandler 建立了 WebServer</p>
</div>
<div class="paragraph">
<p>请求从 Reactor Netty 来到 org.springframework.http.server.reactive.ReactorHttpHandlerAdapter#apply</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_参数转换">参数转换</h2>
<div class="sectionbody">
<div class="paragraph">
<p>org.springframework.web.reactive.result.method.InvocableHandlerMethod#invoke</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_bean的注册和装配wiring">Bean的注册和装配（wiring）</h2>
<div class="sectionbody">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>通过 <code>@Component</code> 注解及包含 <code>@Component</code> 注解的注解对要注册的 <code>bean</code> 进行标记。</p>
</li>
<li>
<p>通过 <code>@Bean</code> 注解对要生成注册 <code>bean</code> 的方法进行标记。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>默认情况下通过扫描发现的 <code>bean</code> 默以类名首字母小写作为其 <code>bean</code> 名称，而使用 <code>@Bean</code> 注解标记的方法注册的bean则以对应方法名作为其 <code>bean</code> 名称，但其名称均可通过注解的参数进行配置。</p>
</div>
<div class="paragraph">
<p>Spring会拦截 <code>@Bean</code> 注解标记的方法，并返回相应的单例 <code>bean</code> （默认情况下）。
使用 <code>@Bean</code> 注解声明 <code>bean</code> 只受 <code>Java</code> 语言的限制，因此你可以使用任何必要的Java功能来产生 <code>bean</code> 。</p>
</div>
</div>
</div>
</div>
</body>
</html>